<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #f0f0f0;
      padding: 10px;
      user-select: none;
    }
    h1 {
      font-size: 24px;
      margin: 10px 0;
    }
    h2 {
      font-size: 14px;
      margin: 5px 0 15px;
      text-align: center;
      line-height: 1.6;
    }
    #controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    button {
      padding: 12px 24px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #2196f3;
      color: white;
    }
    #status {
      font-size: 18px;
      font-weight: bold;
      margin-top: 10px;
    }
    #board {
      display: grid;
      gap: 2px;
      box-sizing: border-box;
      margin: 0 auto;
      transition: all 0.2s ease-in-out;
    }
    .cell {
      background: #bbb;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      color: #333;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s;
      aspect-ratio: 1 / 1;
      user-select: none;
    }
    .cell.open {
      background: #e0e0e0;
    }
    .cell.flag {
      background: #ffeb3b;
      color: #d32f2f;
    }
    .cell.mine {
      background: #f44336;
      color: white;
    }
    .timer {
      font-size: 20px;
      font-weight: bold;
      margin-top: 10px;
    }

    /* ãƒ’ãƒ³ãƒˆç”¨ï¼šå…ƒã®è‰²ã‚’å¤‰ãˆãšå¤–æ ã ã‘è¡¨ç¤º */
    .cell.hint-safe {
      outline: 2px solid #00c853; /* ç·‘ */
      outline-offset: -2px;
    }
    .cell.hint-mine {
      outline: 2px solid #d50000; /* èµ¤ */
      outline-offset: -2px;
    }

    @media (max-width: 600px) {
      button {
        font-size: 16px;
        padding: 10px 20px;
      }
      h1 {
        font-size: 20px;
      }
      #status, .timer {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <h1>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</h1>
  <h2>
    1ãƒã‚¹ã§çˆ†å¼¾2å€‹åˆ†ã‚«ã‚¦ãƒ³ãƒˆã®é‡çˆ†å¼¾ãŒç´›ã‚Œè¾¼ã‚“ã§ã„ã‚‹ã€‚<br>
    ã¾ãŸã€æœ¬æ¥ã‚ˆã‚Š1å°‘ãªãè¡¨ç¤ºã•ã‚Œã‚‹å ´åˆãŒã‚ã‚‹ã€‚ï¼ˆæœ€å°å€¤1ï¼‰
  </h2>
  <div id="controls">
    <button id="resetButton">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
  </div>
  <div id="status"></div>
  <div id="board"></div>
  <div id="timer" class="timer">æ™‚é–“: 0</div>

  <script>
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const resetButton = document.getElementById('resetButton');
    const timerEl = document.getElementById('timer');

    const size = 20;
    const mineCount = 100;
    const DECEPTION_PROBABILITY = 0.5; // 50%ã§è¡¨ç¤ºæ•°å€¤ã‚’-1ï¼ˆãŸã ã—æœ€å°1ï¼‰

    let gameOver = false;
    let openedCount = 0;
    let board = [];
    let timer = null;
    let timerSeconds = 0;
    let firstClick = null; // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ä½ç½®ï¼ˆãã®å‘¨å›²ã¯å®‰å…¨ï¼‰

    resetButton.addEventListener('click', init);

    function init() {
      board = [];
      gameOver = false;
      openedCount = 0;
      firstClick = null;
      statusEl.textContent = '';
      boardEl.innerHTML = '';
      timerSeconds = 0;
      timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
      clearInterval(timer);
      timer = setInterval(() => {
        if (!gameOver) {
          timerSeconds++;
          timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
        }
      }, 1000);

      const shortSide = Math.min(window.innerWidth, window.innerHeight) * 0.9;
      boardEl.style.width = `${shortSide}px`;
      boardEl.style.height = `${shortSide}px`;
      boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      boardEl.style.gridTemplateRows = `repeat(${size}, 1fr)`;

      for (let y = 0; y < size; y++) {
        board[y] = [];
        for (let x = 0; x < size; x++) {
          const cellEl = document.createElement('div');
          cellEl.className = 'cell';
          cellEl.dataset.x = x;
          cellEl.dataset.y = y;
          boardEl.appendChild(cellEl);

          const cell = {
            x,
            y,
            mine: null,           // null / "normal" / "heavy"ï¼ˆå†…éƒ¨ç”¨ã€‚ãƒ’ãƒ³ãƒˆã§ã¯ä½¿ã‚ãªã„ï¼‰
            open: false,
            flag: false,          // è‡ªå‹•ãƒ•ãƒ©ã‚°
            flagType: null,       // null / "unknown" / "normal" / "heavy"
            count: 0,             // çœŸã®ã‚«ã‚¦ãƒ³ãƒˆï¼ˆå†…éƒ¨ç”¨ï¼‰
            displayCount: null,   // ç”»é¢ä¸Šã®æ•°å­—ï¼ˆæ¬ºçè¾¼ã¿ï¼‰â€»ãƒ’ãƒ³ãƒˆã¯ã“ã‚Œã®ã¿ä½¿ç”¨
            hintStatus: null,     // null / "safe" / "mine"
            el: cellEl
          };
          board[y][x] = cell;

          cellEl.addEventListener('click', () => handleCellClick(cell));
        }
      }

      clearHintsAndFlags();
    }

    function handleCellClick(cell) {
      if (gameOver || cell.open) return;

      // æ——ãŒç½®ã„ã¦ã‚ã‚‹ã¨ã“ã‚ã¯æŠ¼ã›ãªã„
      if (cell.flag) return;

      // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ã§åœ°é›·é…ç½®ï¼ˆãã®ãƒã‚¹ã¨å‘¨å›²3x3ã‚’å®‰å…¨ã«ï¼‰
      if (!firstClick) {
        firstClick = { x: cell.x, y: cell.y };
        placeMines();
      }

      openCell(cell);

      if (cell.mine) {
        cell.el.classList.add('mine');
        cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
        endGame(false);
        return;
      }

      if (cell.count === 0) {
        openSurrounding(cell.x, cell.y);
      }

      updateHints(); // è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹æ•°å­—ã ã‘ã‹ã‚‰ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«æ¨è«–

      if (openedCount === size * size - mineCount) {
        endGame(true);
      }
    }

    function placeMines() {
      let mines = 0;
      const safeCells = new Set();

      // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã¨ãã®å‘¨å›²3x3ã¯åœ°é›·ç¦æ­¢
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = firstClick.x + dx;
          const ny = firstClick.y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            safeCells.add(`${nx},${ny}`);
          }
        }
      }

      // é‡çˆ†å¼¾(2ã‚«ã‚¦ãƒ³ãƒˆ)ã®æ•°ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ±ºå®š
      const heavyMineCount = Math.floor(Math.random() * (mineCount + 1));
      let heavyMines = 0;

      while (mines < mineCount) {
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        const cell = board[y][x];

        if (!cell.mine && !safeCells.has(`${x},${y}`)) {
          if (heavyMines < heavyMineCount) {
            cell.mine = "heavy";
            heavyMines++;
          } else {
            cell.mine = "normal";
          }
          mines++;
        }
      }

      // åœ°é›·ä»¥å¤–ã®ãƒã‚¹ã®çœŸã®ã‚«ã‚¦ãƒ³ãƒˆï¼ˆå†…éƒ¨ç”¨ï¼‰
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.mine) continue;
          cell.count = getMineCount(x, y);
        }
      }
    }

    function getMineCount(x, y) {
      let count = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
          if (dx === 0 && dy === 0) continue;
          const neighbor = board[ny][nx];
          if (neighbor.mine === "normal") count += 1;
          else if (neighbor.mine === "heavy") count += 2;
        }
      }
      return count;
    }

    function openCell(cell) {
      if (cell.open || gameOver) return;
      cell.open = true;
      openedCount++;
      cell.el.classList.add('open');

      // é–‹ã„ãŸã‚»ãƒ«ä¸Šã®ãƒ•ãƒ©ã‚°ã¯æ¶ˆã™ï¼ˆä¿é™ºï¼‰
      if (cell.flag) {
        cell.flag = false;
        cell.flagType = null;
        cell.el.classList.remove('flag');
      }

      if (!cell.mine) {
        if (cell.count === 0) {
          // 0 ã®ã¨ãã¯è¡¨ç¤ºã—ãªã„ãŒã€displayCount ã«ã¯ 0 ã‚’å…¥ã‚Œã¦ãŠã
          cell.displayCount = 0;
          cell.el.textContent = '';
        } else {
          let displayCount = cell.count;
          if (Math.random() < DECEPTION_PROBABILITY) {
            displayCount = Math.max(1, cell.count - 1);
          }
          cell.displayCount = displayCount;   // â˜… ãƒ’ãƒ³ãƒˆã¯ã“ã‚Œã ã‘ã‚’è¦‹ã‚‹
          cell.el.textContent = displayCount;
          cell.el.style.color = getNumberColor(displayCount);
        }
      }
    }

    function getNumberColor(num) {
      switch (num) {
        case 1: return '#1976d2';
        case 2: return '#388e3c';
        case 3: return '#d32f2f';
        case 4: return '#7b1fa2';
        case 5: return '#f57c00';
        case 6: return '#00897b';
        case 7: return '#616161';
        case 8: return '#000000';
        default: return '#000000';
      }
    }

    function openSurrounding(x, y) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
          if (dx === 0 && dy === 0) continue;
          const neighbor = board[ny][nx];
          if (!neighbor.open && !neighbor.mine) {
            openCell(neighbor);
            if (neighbor.count === 0) {
              openSurrounding(nx, ny);
            }
          }
        }
      }
    }

    function endGame(win) {
      gameOver = true;
      clearInterval(timer);
      statusEl.textContent = win ? 'ã‚¯ãƒªã‚¢ï¼' : 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼';

      // åœ°é›·ã‚’å…¨è¡¨ç¤ºï¼ˆã‚²ãƒ¼ãƒ çµ‚äº†å¾Œã ã‘å†…éƒ¨æƒ…å ±ã‚’é–‹ç¤ºï¼‰
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.mine && !cell.open) {
            cell.el.classList.add('mine');
            cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
          }
        }
      }
    }

    // ---------- ãƒ’ãƒ³ãƒˆ & è‡ªå‹•ãƒ•ãƒ©ã‚°ï¼ˆè¡¨ç¤ºæƒ…å ±ã ã‘ã‚’ä½¿ç”¨ï¼‰ ----------

    function clearHintsAndFlags() {
      for (let y = 0; y < size; y++) {
        if (!board[y]) continue;
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (!c) continue;
          c.hintStatus = null;
          c.el.classList.remove('hint-safe', 'hint-mine');
          // ãƒ•ãƒ©ã‚°ã‚‚æ¯å›ãƒ­ã‚¸ãƒƒã‚¯ã‹ã‚‰å†è¨ˆç®—ã™ã‚‹ã®ã§ã„ã£ãŸã‚“ãƒªã‚»ãƒƒãƒˆ
          if (!c.open) {
            c.flag = false;
            c.flagType = null;
            c.el.classList.remove('flag');
            c.el.textContent = '';
          }
        }
      }
    }

    function getNeighbors(x, y) {
      const res = [];
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            res.push(board[ny][nx]);
          }
        }
      }
      return res;
    }

    // displayCount ã¨ã€Œ1å°ã•ã„å¯èƒ½æ€§ã€ã‚’è€ƒæ…®ã—ãŸâ€œã‚°ãƒ­ãƒ¼ãƒãƒ«â€æ¨è«–
    // - æœªã‚ªãƒ¼ãƒ—ãƒ³ã§æ•°å­—ã«éš£æ¥ã—ã¦ã„ã‚‹ãƒã‚¹ã‚’å¤‰æ•°ã¨ã—ã¦ {0,1,2} ã‚’å‰²ã‚Šå½“ã¦ã‚‹
    // - å„æ•°å­—ãƒã‚¹ï¼š sum(è¿‘å‚å¤‰æ•°) âˆˆ {d, d+1}ï¼ˆd==0ãªã‚‰ {0}ï¼‰
    // - ã™ã¹ã¦ã®åˆ¶ç´„ã‚’åŒæ™‚ã«æº€ãŸã™ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ DFS+æåˆˆã‚Šã§åˆ—æŒ™ã—ã€å„å¤‰æ•°ã®å€¤ã®é›†åˆã‚’é›†è¨ˆ
    function updateHints() {
      clearHintsAndFlags();
      if (!firstClick) return; // ã¾ã ä½•ã‚‚è¦‹ãˆã¦ã„ãªã„

      // 1. ãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢ï¼ˆæœªã‚ªãƒ¼ãƒ—ãƒ³ã‹ã¤æ•°å­—ã«éš£æ¥ã—ã¦ã„ã‚‹ãƒã‚¹ï¼‰ã‚’æŠ½å‡º
      const idMap = Array.from({ length: size }, () =>
        Array(size).fill(-1)
      );
      const frontier = [];

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.open) continue;
          const neighbors = getNeighbors(x, y);
          let hasOpenNumber = false;
          for (const n of neighbors) {
            if (n.open && n.displayCount != null) {
              hasOpenNumber = true;
              break;
            }
          }
          if (hasOpenNumber) {
            idMap[y][x] = frontier.length;
            frontier.push(cell);
          }
        }
      }

      const F = frontier.length;
      if (F === 0) return;

      // 2. æ•°å­—ãƒã‚¹ã‹ã‚‰åˆ¶ç´„ã‚’æ§‹æˆ
      const constraints = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (!cell.open) continue;

          const d = (cell.displayCount != null) ? cell.displayCount : 0;
          const neighbors = getNeighbors(x, y);
          const vars = [];
          for (const n of neighbors) {
            if (!n.open) {
              const vid = idMap[n.y][n.x];
              if (vid !== -1) vars.push(vid);
            }
          }
          if (vars.length === 0) continue;

          let allowedSums;
          if (d === 0) {
            allowedSums = [0];
          } else {
            allowedSums = [d, d + 1];
          }
          constraints.push({ vars, allowedSums });
        }
      }

      if (constraints.length === 0) return;

      // 3. å¤‰æ•°ã‚°ãƒ©ãƒ•ã‚’ä½œã£ã¦é€£çµæˆåˆ†ã”ã¨ã«åˆ†å‰²ï¼ˆå¤§ãã™ãã‚‹éƒ¨åˆ†ã‚’é¿ã‘ã‚‹ãŸã‚ï¼‰
      const adj = Array.from({ length: F }, () => []);
      for (const c of constraints) {
        const vs = c.vars;
        for (let i = 0; i < vs.length; i++) {
          for (let j = i + 1; j < vs.length; j++) {
            const a = vs[i];
            const b = vs[j];
            adj[a].push(b);
            adj[b].push(a);
          }
        }
      }

      const visited = Array(F).fill(false);
      const components = [];
      for (let i = 0; i < F; i++) {
        if (visited[i]) continue;
        const queue = [i];
        visited[i] = true;
        const comp = [];
        while (queue.length > 0) {
          const v = queue.shift();
          comp.push(v);
          for (const nb of adj[v]) {
            if (!visited[nb]) {
              visited[nb] = true;
              queue.push(nb);
            }
          }
        }
        components.push(comp);
      }

      // å„å¤‰æ•°ã®ã€Œå–ã‚Šã†ã‚‹å€¤ã®é›†åˆã€ã‚’åˆæœŸåŒ–
      const varPossible = Array.from({ length: F }, () => new Set([0, 1, 2]));

      // 4. å„æˆåˆ†ã”ã¨ã« SAT ã—ã¦ varPossible ã‚’è©°ã‚ã‚‹
      for (const comp of components) {
        const compSet = new Set(comp);
        const compIndexMap = new Map(); // global id -> local index
        comp.forEach((gid, idx) => compIndexMap.set(gid, idx));

        // ã“ã®æˆåˆ†ã«é–¢ä¿‚ã™ã‚‹åˆ¶ç´„ã ã‘æŠœãå‡ºã—
        const compConstraints = [];
        for (const c of constraints) {
          const localVars = [];
          for (const vid of c.vars) {
            if (compSet.has(vid)) {
              localVars.push(compIndexMap.get(vid));
            }
          }
          if (localVars.length === 0) continue;
          compConstraints.push({
            vars: localVars,             // local indices
            allowedSums: c.allowedSums   // ãã®ã¾ã¾
          });
        }

        const numVars = comp.length;
        const numCons = compConstraints.length;

        // å¤‰æ•°ãŒå¤šã™ãã‚‹æˆåˆ†ã¯è«¦ã‚ã‚‹ï¼ˆçˆ†ç™ºé˜²æ­¢ï¼‰
        if (numVars > 15) {
          continue;
        }

        const consSum = Array(numCons).fill(0);
        const consRemain = compConstraints.map(c => c.vars.length);

        const varCons = Array.from({ length: numVars }, () => []);
        for (let ci = 0; ci < numCons; ci++) {
          const vs = compConstraints[ci].vars;
          for (const v of vs) {
            varCons[v].push(ci);
          }
        }

        const compPossible = Array.from({ length: numVars }, () => new Set());
        const assign = Array(numVars).fill(0);
        let hasSolution = false;

        function dfsVar(pos) {
          if (pos === numVars) {
            // å…¨å¤‰æ•°å‰²ã‚Šå½“ã¦å¾Œã€å…¨åˆ¶ç´„ãŒã¡ã‚‡ã†ã© allowedSums ã‚’æº€ãŸã™ã‹ç¢ºèª
            for (let ci = 0; ci < numCons; ci++) {
              const s = consSum[ci];
              const allowed = compConstraints[ci].allowedSums;
              let ok = false;
              for (const a of allowed) {
                if (s === a) {
                  ok = true;
                  break;
                }
              }
              if (!ok) return;
            }
            hasSolution = true;
            for (let v = 0; v < numVars; v++) {
              compPossible[v].add(assign[v]);
            }
            return;
          }

          for (const val of [0, 1, 2]) {
            assign[pos] = val;
            let pruned = false;
            const touched = varCons[pos];
            for (const ci of touched) {
              consSum[ci] += val;
              consRemain[ci]--;

              const allowed = compConstraints[ci].allowedSums;
              const minTotal = consSum[ci];
              const maxTotal = consSum[ci] + consRemain[ci] * 2;

              let okRange = false;
              for (const a of allowed) {
                if (a >= minTotal && a <= maxTotal) {
                  okRange = true;
                  break;
                }
              }
              if (!okRange) {
                pruned = true;
              }
            }

            if (!pruned) {
              dfsVar(pos + 1);
            }

            for (const ci of touched) {
              consSum[ci] -= val;
              consRemain[ci]++;
            }
          }
        }

        dfsVar(0);

        if (!hasSolution) {
          // ã“ã®æˆåˆ†è‡ªä½“ãŒçŸ›ç›¾ã—ã¦ã„ã‚‹ â†’ ä»Šå›ã¯ä½•ã‚‚çµã‚‰ãªã„
          continue;
        }

        for (let li = 0; li < numVars; li++) {
          const gid = comp[li];
          const pset = compPossible[li];
          if (pset.size === 0) continue;
          varPossible[gid] = pset;
        }
      }

      // 5. varPossible ã‚’å…ƒã«å®‰å…¨ï¼åœ°é›·ï¼‹è‡ªå‹•ãƒ•ãƒ©ã‚°ã‚’ä»˜ã‘ã‚‹
      for (let i = 0; i < F; i++) {
        const cell = frontier[i];
        const s = varPossible[i];

        const has0 = s.has(0);
        const has1 = s.has(1);
        const has2 = s.has(2);

        if (!has0 && !has1 && !has2) continue;

        // å¸¸ã«0 â†’ å®‰å…¨ç¢ºå®š
        if (!has1 && !has2) {
          markSafe(cell);
        }

        // 0 ãŒã‚ã‚Šå¾—ãªã„ï¼ˆ1 or 2 ã®ã¿ï¼‰ â†’ åœ°é›·ç¢ºå®š
        if (!has0 && (has1 || has2)) {
          let type = "unknown";
          if (has1 && !has2) type = "normal";
          else if (!has1 && has2) type = "heavy";
          markMine(cell, type);
        }
      }
    }

    function markSafe(cell) {
      if (cell.hintStatus === "mine") return;
      cell.hintStatus = "safe";
      cell.el.classList.add('hint-safe');
    }

    function markMine(cell, mineType) {
      cell.hintStatus = "mine";
      cell.el.classList.add('hint-mine');

      // è‡ªå‹•ãƒ•ãƒ©ã‚°ä»˜ä¸ï¼ˆã‚ã‹ã‚‰ãªã„ï¼1ï¼2ï¼‰
      cell.flag = true;
      cell.flagType = mineType;
      cell.el.classList.add('flag');

      if (mineType === "normal") {
        cell.el.textContent = '1';
      } else if (mineType === "heavy") {
        cell.el.textContent = '2';
      } else {
        cell.el.textContent = 'ğŸš©?';
      }
    }

    // åˆæœŸåŒ–
    init();
  </script>
</body>
</html>
