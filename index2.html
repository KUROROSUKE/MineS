<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #f0f0f0;
      padding: 10px;
      user-select: none;
    }
    h1 {
      font-size: 24px;
      margin: 10px 0;
    }
    h2 {
      font-size: 14px;
      margin: 5px 0 15px;
      text-align: center;
      line-height: 1.6;
    }
    #controls {
      margin-bottom: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      padding: 8px 16px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background: #1976d2;
      color: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    button:hover {
      background: #1565c0;
    }
    #status {
      min-height: 24px;
      margin-bottom: 8px;
      font-weight: bold;
      font-size: 18px;
    }
    #board {
      display: grid;
      background: #bdbdbd;
      border: 2px solid #9e9e9e;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      touch-action: manipulation;
    }
    .cell {
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      border: 1px solid #9e9e9e;
      background: #e0e0e0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.1s, box-shadow 0.1s;
    }
    .cell.open {
      background: #eeeeee;
      border-color: #bdbdbd;
      cursor: default;
    }
    .cell.flag {
      background: #fff9c4;
    }
    .cell.mine {
      background: #ff5252;
      color: #ffffff;
    }
    .timer {
      margin-top: 8px;
      font-size: 18px;
    }

    /* ãƒ’ãƒ³ãƒˆç”¨æ  */
    .cell.hint-safe {
      box-shadow: 0 0 0 2px #4caf50 inset; /* å®‰å…¨: ç·‘æ  */
    }
    .cell.hint-mine {
      box-shadow: 0 0 0 2px #f44336 inset; /* åœ°é›·ç¢ºå®š: èµ¤æ  */
    }

    @media (max-width: 600px) {
      button {
        font-size: 16px;
        padding: 10px 20px;
      }
      h1 {
        font-size: 20px;
      }
      #status, .timer {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <h1>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</h1>
  <h2>
    1ãƒã‚¹ã§çˆ†å¼¾2å€‹åˆ†ã‚«ã‚¦ãƒ³ãƒˆã®é‡çˆ†å¼¾ãŒç´›ã‚Œè¾¼ã‚“ã§ã„ã‚‹ã€‚<br>
    ã¾ãŸã€æœ¬æ¥ã‚ˆã‚Š1å°‘ãªãè¡¨ç¤ºã•ã‚Œã‚‹å ´åˆãŒã‚ã‚‹ã€‚ï¼ˆæœ€å°å€¤1ï¼‰
  </h2>
  <div id="controls">
    <button id="flagButton">ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ OFF</button>
    <button id="resetButton">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
  </div>
  <div id="status"></div>
  <div id="board"></div>
  <div id="timer" class="timer">æ™‚é–“: 0</div>

  <script>
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const flagButton = document.getElementById('flagButton');
    const resetButton = document.getElementById('resetButton');
    const timerEl = document.getElementById('timer');

    // åŸºç¤è¨­å®š
    const size = 20;
    const mineCount = 100;
    const DECEPTION_PROBABILITY = 0.5; // 50%ã§è¡¨ç¤ºæ•°å€¤ã‚’-1ï¼ˆãŸã ã—æœ€å°1ï¼‰

    let gameOver = false;
    let flagMode = false;
    let openedCount = 0;
    let board = [];
    let timer = null;
    let timerSeconds = 0;
    let firstClick = null; // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ä½ç½®ï¼ˆå‘¨å›²ã‚’å®‰å…¨ã«ã™ã‚‹ãŸã‚ï¼‰

    flagButton.addEventListener('click', () => {
      flagMode = !flagMode;
      flagButton.textContent = flagMode
        ? 'ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ ON'
        : 'ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ OFF';
    });

    resetButton.addEventListener('click', init);

    function init() {
      board = [];
      gameOver = false;
      openedCount = 0;
      firstClick = null;
      statusEl.textContent = '';
      boardEl.innerHTML = '';
      timerSeconds = 0;
      timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
      clearInterval(timer);
      timer = setInterval(() => {
        if (!gameOver) {
          timerSeconds++;
          timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
        }
      }, 1000);

      const shortSide = Math.min(window.innerWidth, window.innerHeight) * 0.9;
      boardEl.style.width = `${shortSide}px`;
      boardEl.style.height = `${shortSide}px`;
      boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      boardEl.style.gridTemplateRows = `repeat(${size}, 1fr)`;

      for (let y = 0; y < size; y++) {
        board[y] = [];
        for (let x = 0; x < size; x++) {
          const cellEl = document.createElement('div');
          cellEl.className = 'cell';
          cellEl.dataset.x = x;
          cellEl.dataset.y = y;
          boardEl.appendChild(cellEl);

          const cell = {
            x,
            y,
            mine: null,            // null / "normal" / "heavy"
            open: false,
            flag: false,           // ãƒ•ãƒ©ã‚°ãŒç«‹ã£ã¦ã„ã‚‹ã‹
            flagType: null,        // null / "unknown" / "normal" / "heavy"
            count: 0,
            hintStatus: null,      // null / "safe" / "mine"
            mineTypeHint: null,    // null / "normal" / "heavy"
            el: cellEl
          };
          board[y][x] = cell;

          cellEl.addEventListener('click', () => handleCellClick(cell));
        }
      }

      clearHints();
    }

    function handleCellClick(cell) {
      if (gameOver || cell.open) return;

      // æ——ãƒ¢ãƒ¼ãƒ‰ï¼šãƒ•ãƒ©ã‚°çŠ¶æ…‹ã‚’å¾ªç’°
      if (flagMode) {
        if (!cell.open) {
          cycleFlag(cell);
          updateHints(); // ãƒ•ãƒ©ã‚°æƒ…å ±ã‚’ä½¿ã£ã¦å†æ¨è«–
        }
        return;
      }

      // ãƒ•ãƒ©ã‚°ãŒç«‹ã£ã¦ã„ã‚‹ãƒã‚¹ã¯é–‹ã‹ãªã„
      if (cell.flag) return;

      // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ã§åœ°é›·é…ç½®ï¼ˆãã®ãƒã‚¹ã¨å‘¨å›²3x3ã¯å®‰å…¨ï¼‰
      if (!firstClick) {
        firstClick = { x: cell.x, y: cell.y };
        placeMines();
      }

      openCell(cell);

      // åœ°é›·ã‚’è¸ã‚“ã 
      if (cell.mine) {
        cell.el.classList.add('mine');
        cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
        endGame(false);
        return;
      }

      // å‘¨å›²ã«ã‚«ã‚¦ãƒ³ãƒˆãŒãªã„ãªã‚‰é€£é–ã§é–‹ã
      if (cell.count === 0) {
        openSurrounding(cell.x, cell.y);
      }

      // ãƒ’ãƒ³ãƒˆæ›´æ–°
      updateHints();

      // ã‚¯ãƒªã‚¢åˆ¤å®š
      if (openedCount === size * size - mineCount) {
        endGame(true);
      }
    }

    // ãƒ•ãƒ©ã‚°çŠ¶æ…‹ã‚’å¾ªç’°: ãªã— â†’ ä¸æ˜ â†’ 1 â†’ 2 â†’ ãªã—
    function cycleFlag(cell) {
      if (!cell.flag) {
        // ãªã— â†’ ä¸æ˜
        cell.flag = true;
        cell.flagType = "unknown";
        cell.el.classList.add('flag');
        cell.el.textContent = 'ğŸš©?';
      } else if (cell.flagType === "unknown") {
        // ä¸æ˜ â†’ 1ã‚«ã‚¦ãƒ³ãƒˆåœ°é›·å€™è£œ
        cell.flagType = "normal";
        cell.el.classList.add('flag');
        cell.el.textContent = '1';
      } else if (cell.flagType === "normal") {
        // 1 â†’ 2ã‚«ã‚¦ãƒ³ãƒˆåœ°é›·å€™è£œ
        cell.flagType = "heavy";
        cell.el.classList.add('flag');
        cell.el.textContent = '2';
      } else {
        // 2 â†’ ãªã—
        cell.flag = false;
        cell.flagType = null;
        cell.el.classList.remove('flag');
        cell.el.textContent = '';
      }
    }

    function placeMines() {
      let mines = 0;
      const safeCells = new Set();

      // æœ€åˆã«ã‚¯ãƒªãƒƒã‚¯ã—ãŸãƒã‚¹ã¨ãã®å‘¨å›²3x3ã¯åœ°é›·ç¦æ­¢
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = firstClick.x + dx;
          const ny = firstClick.y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            safeCells.add(`${nx},${ny}`);
          }
        }
      }

      // é‡çˆ†å¼¾ï¼ˆ2ã‚«ã‚¦ãƒ³ãƒˆåœ°é›·ï¼‰ã®æ•°ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã§æ±ºã‚ã‚‹
      const heavyMineCount = Math.floor(Math.random() * (mineCount + 1));
      let heavyMines = 0;

      while (mines < mineCount) {
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        const cell = board[y][x];

        if (!cell.mine && !safeCells.has(`${x},${y}`)) {
          if (heavyMines < heavyMineCount) {
            cell.mine = "heavy";
            heavyMines++;
          } else {
            cell.mine = "normal";
          }
          mines++;
        }
      }

      // å„ãƒã‚¹ã®ã‚«ã‚¦ãƒ³ãƒˆè¨ˆç®—ï¼ˆé‡çˆ†å¼¾ã¯2ã‚«ã‚¦ãƒ³ãƒˆï¼‰
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.mine) continue;
          cell.count = getMineCount(x, y);
        }
      }
    }

    function getMineCount(x, y) {
      let count = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
          if (dx === 0 && dy === 0) continue;
          const neighbor = board[ny][nx];
          if (neighbor.mine === "normal") count += 1;
          else if (neighbor.mine === "heavy") count += 2;
        }
      }
      return count;
    }

    function openCell(cell) {
      if (cell.open || gameOver) return;
      cell.open = true;
      openedCount++;
      cell.el.classList.add('open');

      // é–‹ã„ãŸã¨ãã¯ãƒ•ãƒ©ã‚°ã¯æ¶ˆã—ã¦ã—ã¾ã†ï¼ˆé€šå¸¸ã¯ãƒ•ãƒ©ã‚°ä»˜ããƒã‚¹ã¯é–‹ã‹ãªã„ã®ã§ä¿é™ºï¼‰
      if (cell.flag) {
        cell.flag = false;
        cell.flagType = null;
        cell.el.classList.remove('flag');
      }

      if (cell.count > 0 && !cell.mine) {
        // æ¬ºçã‚·ã‚¹ãƒ†ãƒ ï¼šä¸€å®šç¢ºç‡ã§è¡¨ç¤ºæ•°å€¤ã‚’1æ¸›ã‚‰ã™ï¼ˆãŸã ã—æœ€å°1ï¼‰
        let displayCount = cell.count;
        if (Math.random() < DECEPTION_PROBABILITY) {
          displayCount = Math.max(1, cell.count - 1);
        }
        cell.el.textContent = displayCount;
        cell.el.style.color = getNumberColor(displayCount);
      }
    }

    // æ•°å­—ã«å¿œã˜ã¦è‰²ä»˜ã‘
    function getNumberColor(num) {
      switch (num) {
        case 1: return '#1976d2'; // é’
        case 2: return '#388e3c'; // ç·‘
        case 3: return '#d32f2f'; // èµ¤
        case 4: return '#7b1fa2'; // ç´«
        case 5: return '#f57c00'; // ã‚ªãƒ¬ãƒ³ã‚¸
        case 6: return '#00897b'; // ãƒ†ã‚£ãƒ¼ãƒ«
        case 7: return '#616161'; // ã‚°ãƒ¬ãƒ¼
        case 8: return '#000000'; // é»’
        default: return '#000000';
      }
    }

    function openSurrounding(x, y) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
          if (dx === 0 && dy === 0) continue;
          const neighbor = board[ny][nx];
          if (!neighbor.open && !neighbor.mine) {
            openCell(neighbor);
            if (neighbor.count === 0) {
              openSurrounding(nx, ny);
            }
          }
        }
      }
    }

    function endGame(win) {
      gameOver = true;
      clearInterval(timer);
      statusEl.textContent = win ? 'ã‚¯ãƒªã‚¢ï¼' : 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼';

      // åœ°é›·ã‚’å…¨ã¦è¡¨ç¤º
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.mine && !cell.open) {
            cell.el.classList.add('mine');
            cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
          }
        }
      }
    }

    // ---------- ãƒ’ãƒ³ãƒˆé–¢é€£ãƒ­ã‚¸ãƒƒã‚¯ ----------

    function clearHints() {
      for (let y = 0; y < size; y++) {
        if (!board[y]) continue;
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (!c) continue;
          c.hintStatus = null;
          c.mineTypeHint = null;
          c.el.classList.remove('hint-safe', 'hint-mine');
        }
      }
    }

    // å˜ä¸€ã®æ•°å­—ãƒã‚¹ã‹ã‚‰ã®ãƒ­ãƒ¼ã‚«ãƒ«æ¨è«–
    // ãƒ»ãƒ•ãƒ©ã‚°æƒ…å ±ï¼ˆä¸æ˜ / 1 / 2ï¼‰ã‚’åˆ©ç”¨
    // ãƒ»æ®‹ã‚Šãƒ¦ãƒ‹ãƒƒãƒˆ0 â†’ å‘¨å›²ã®æœªç¢ºå®šãƒã‚¹ã¯å®‰å…¨
    // ãƒ»æ®‹ã‚Šãƒ¦ãƒ‹ãƒƒãƒˆ1 or 2 ã‹ã¤ æœªç¢ºå®šãƒã‚¹1ã¤ â†’ ãã®ãƒã‚¹ã¯åœ°é›·ç¢ºå®šï¼ˆ1 or 2 ã‚‚ç¢ºå®šï¼‰
    function updateHints() {
      clearHints();
      if (!firstClick) return; // ã¾ã åœ°é›·ãŒé…ç½®ã•ã‚Œã¦ã„ãªã„

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          // é–‹ã„ã¦ã„ã¦ã€åœ°é›·ã§ãªãã€æ•°å­—ãƒã‚¹ã®ã¿å¯¾è±¡
          if (!cell.open || cell.mine || cell.count <= 0) continue;

          const neighbors = [];
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              const nx = x + dx;
              const ny = y + dy;
              if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
                neighbors.push(board[ny][nx]);
              }
            }
          }

          let flaggedNormal = 0;
          let flaggedHeavy = 0;
          let flaggedUnknown = 0;
          const unopened = [];

          for (const n of neighbors) {
            if (n.flag) {
              if (n.flagType === "normal") flaggedNormal++;
              else if (n.flagType === "heavy") flaggedHeavy++;
              else flaggedUnknown++; // "unknown"
            } else if (!n.open) {
              unopened.push(n);
            }
          }

          const usedMin = flaggedNormal + 2 * flaggedHeavy + flaggedUnknown;
          const remainMin = cell.count - usedMin;

          // ãƒ«ãƒ¼ãƒ«A: æ®‹ã‚Š0ãƒ¦ãƒ‹ãƒƒãƒˆ â†’ æœªãƒ•ãƒ©ã‚°æœªã‚ªãƒ¼ãƒ—ãƒ³ã¯å…¨éƒ¨å®‰å…¨
          if (remainMin === 0) {
            for (const n of unopened) {
              markSafe(n);
            }
          }

          // ãƒ«ãƒ¼ãƒ«B: æ®‹ã‚Šãƒ¦ãƒ‹ãƒƒãƒˆ>0 ã‹ã¤ å€™è£œãŒ1ãƒã‚¹ã®ã¿ â†’ ãã®ãƒã‚¹ã¯åœ°é›·ç¢ºå®š
          if (remainMin > 0 && unopened.length === 1 && remainMin <= 2) {
            const target = unopened[0];
            const type = remainMin === 1 ? "normal" : "heavy";
            markMine(target, type);
          }
        }
      }
    }

    function markSafe(cell) {
      // æ—¢ã«ã€Œåœ°é›·ç¢ºå®šãƒ’ãƒ³ãƒˆã€ãŒä»˜ã„ã¦ã„ãŸã‚‰ä¸Šæ›¸ãã—ãªã„
      if (cell.hintStatus === "mine") return;
      cell.hintStatus = "safe";
      cell.el.classList.add('hint-safe');
    }

    function markMine(cell, mineType) {
      cell.hintStatus = "mine";
      cell.mineTypeHint = mineType;
      cell.el.classList.add('hint-mine');

      // æ—¢ã«ãƒ•ãƒ©ã‚°ãŒç«‹ã£ã¦ã„ã¦ç¨®åˆ¥ä¸æ˜ãªã‚‰ã€ç¨®åˆ¥ã‚’è£œå®Œã—ã¦è¡¨ç¤ºã‚’æ›´æ–°
      if (cell.flag && (!cell.flagType || cell.flagType === "unknown")) {
        cell.flagType = mineType;
        cell.el.classList.add('flag');
        cell.el.textContent = (mineType === "heavy") ? '2' : '1';
      }
    }

    // åˆæœŸåŒ–é–‹å§‹
    init();
  </script>
</body>
</html>
