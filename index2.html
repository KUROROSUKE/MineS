<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ãƒ­ã‚¸ãƒƒã‚¯ä»˜ããƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #f0f0f0;
      padding: 10px;
      user-select: none;
    }
    h1 {
      font-size: 24px;
      margin: 10px 0;
    }
    #controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    button {
      padding: 12px 24px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #2196f3;
      color: white;
    }
    button.flag-mode {
      background: #ff9800;
    }
    #board {
      display: grid;
      gap: 2px;
      background: #999;
      border-radius: 4px;
      overflow: hidden;
      touch-action: manipulation;
    }
    .cell {
      background: #ccc;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
    }
    .cell.open {
      background: #eee;
      cursor: default;
    }
    .cell.mine {
      background: #e91e63;
      color: #fff;
    }
    .cell.flag {
      background: #ffc107;
    }
    .timer {
      margin-top: 10px;
      font-weight: bold;
    }

    /* ãƒ’ãƒ³ãƒˆè¡¨ç¤ºç”¨ */
    .cell.logic-safe {
      box-shadow: 0 0 0 3px #4caf50 inset; /* ç·‘æ ï¼šå®‰å…¨ç¢ºå®š or å®‰å…¨å€™è£œ */
    }
    .cell.logic-mine {
      box-shadow: 0 0 0 3px #f44336 inset; /* èµ¤æ ï¼šåœ°é›·ç¢ºå®š */
    }
  </style>
</head>
<body>
  <h1>ãƒ­ã‚¸ãƒƒã‚¯ä»˜ããƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</h1>
  <h2>
    ãƒ»ä¸€éƒ¨ã®çˆ†å¼¾ã¯ã€Œé‡çˆ†å¼¾ã€ã§ã€å‘¨å›²ã« 2 å€‹åˆ†ã¨ã—ã¦æ•°ãˆä¸Šã’ã‚‰ã‚Œã‚‹ã€‚<br>
    ãƒ»è¡¨ç¤ºã•ã‚Œã‚‹æ•°å­—ã¯ã€æœ¬æ¥ã®åˆè¨ˆã‹ã‚‰ 1 å°‘ãªã„ã“ã¨ãŒã‚ã‚‹ï¼ˆãŸã ã— 1 æœªæº€ã«ã¯ãªã‚‰ãªã„ï¼‰ã€‚<br>
    ãƒ»ãƒ’ãƒ³ãƒˆã¯ã€Œæ•°å­—ã ã‘ã€ã‚’ä½¿ã£ã¦ã€0/1/2 ã®å…¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ·±ã•åˆ¶é™ä»˜ãã§ç·å½“ãŸã‚Šã—ã¾ã™ã€‚<br>
    ãƒ»ä½•ã‚‚ç¢ºå®šã—ãªã„ã¨ãã¯ã€å®‰å…¨ãã†ãªä¸Šä½ 3 ãƒã‚¹ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
  </h2>

  <div id="controls">
    <button id="flagButton">ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ OFF</button>
    <button id="resetButton">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
    <button id="autoLogicButton">ğŸ¤– ãƒ­ã‚¸ãƒƒã‚¯è‡ªå‹•æ“ä½œ OFF</button>
  </div>
  <div id="status"></div>
  <div id="board"></div>
  <div id="timer" class="timer">æ™‚é–“: 0</div>

  <!-- ã‚²ãƒ¼ãƒ æœ¬ä½“ -->
  <script>
    const boardEl   = document.getElementById('board');
    const statusEl  = document.getElementById('status');
    const flagButton  = document.getElementById('flagButton');
    const resetButton = document.getElementById('resetButton');
    const timerEl   = document.getElementById('timer');
    const autoLogicButton = document.getElementById('autoLogicButton');

    const size = 20;
    const mineCount = 100;          // çˆ†å¼¾ã®å€‹æ•°ï¼ˆé‡çˆ†ã‚‚ 1 å€‹ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆï¼‰
    const DECEPTION_PROBABILITY = 0.5; // 50%ã§è¡¨ç¤ºæ•°å€¤ã‚’-1ï¼ˆãŸã ã—æœ€å°1ï¼‰

    let gameOver    = false;
    let flagMode    = false;
    let openedCount = 0;
    let board       = [];
    let timer;
    let timerSeconds = 0;
    let firstClick  = null;
    let autoLogic = false;

    flagButton.addEventListener('click', () => {
      flagMode = !flagMode;
      flagButton.textContent = flagMode ? 'ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ ON' : 'ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ OFF';
      flagButton.classList.toggle('flag-mode', flagMode);
    });

    resetButton.addEventListener('click', init);

    autoLogicButton.addEventListener('click', () => {
      autoLogic = !autoLogic;
      autoLogicButton.textContent = autoLogic
        ? 'ğŸ¤– ãƒ­ã‚¸ãƒƒã‚¯è‡ªå‹•æ“ä½œ ON'
        : 'ğŸ¤– ãƒ­ã‚¸ãƒƒã‚¯è‡ªå‹•æ“ä½œ OFF';
      // çŠ¶æ…‹ãŒå¤‰ã‚ã£ãŸã¨ãã«ä¸€åº¦ã ã‘ãƒ’ãƒ³ãƒˆã‚’æ›´æ–°
      if (autoLogic && typeof requestHint === 'function' && !gameOver) {
        requestHint();
      }
    });

    function requestHint() {
      if (typeof showHint === 'function' && !gameOver) {
        showHint();
      }
    }

    function init() {
      board = [];
      gameOver = false;
      openedCount = 0;
      firstClick = null;
      statusEl.textContent = '';
      boardEl.innerHTML = '';
      timerSeconds = 0;
      timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
      clearInterval(timer);
      timer = setInterval(() => {
        if (!gameOver) {
          timerSeconds++;
          timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
        }
      }, 1000);

      const shortSide = Math.min(window.innerWidth, window.innerHeight) * 0.9;
      boardEl.style.width  = `${shortSide}px`;
      boardEl.style.height = `${shortSide}px`;
      boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      boardEl.style.gridTemplateRows    = `repeat(${size}, 1fr)`;

      for (let y = 0; y < size; y++) {
        board[y] = [];
        for (let x = 0; x < size; x++) {
          const cellEl = document.createElement('div');
          cellEl.className = 'cell';
          cellEl.dataset.x = x;
          cellEl.dataset.y = y;
          boardEl.appendChild(cellEl);

          const cell = {
            x,
            y,
            mine: null,   // null / "normal" / "heavy"
            open: false,
            flag: false,
            count: 0,
            el: cellEl
          };
          board[y][x] = cell;

          cellEl.addEventListener('click', () => handleCellClick(cell));
        }
      }

      if (typeof clearHints === 'function') clearHints();
    }

    function handleCellClick(cell) {
      if (gameOver) return;

      // æ——ãƒ¢ãƒ¼ãƒ‰ï¼šON ã®ã¨ãã¯æ——ã® ON/OFF ã ã‘
      if (flagMode) {
        if (!cell.open) {
          if (typeof clearHints === 'function') clearHints();
          cell.flag = !cell.flag;
          cell.el.classList.toggle('flag', cell.flag);
          cell.el.textContent = cell.flag ? 'ğŸš©' : '';
          requestHint();
        }
        return;
      }

      // é€šå¸¸ã‚¯ãƒªãƒƒã‚¯
      if (cell.open || cell.flag) return;
      if (typeof clearHints === 'function') clearHints();

      // åˆã‚¯ãƒªãƒƒã‚¯ã§åœ°é›·é…ç½®
      if (!firstClick) {
        firstClick = { x: cell.x, y: cell.y };
        placeMines();
      }

      // åœ°é›·ã‚’è¸ã‚“ã 
      if (cell.mine) {
        cell.el.classList.add('mine');
        cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
        endGame(false);
        return;
      }

      openCell(cell);

      if (cell.count === 0) {
        openSurrounding(cell.x, cell.y);
      }

      if (openedCount === size * size - mineCount) {
        endGame(true);
        return;
      }

      requestHint();
    }

    function placeMines() {
      let mines = 0;
      const safeCells = new Set();

      // åˆæ‰‹ã¨ãã®å‘¨å›²ã¯å®‰å…¨
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = firstClick.x + dx;
          const ny = firstClick.y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            safeCells.add(ny * size + nx);
          }
        }
      }

      while (mines < mineCount) {
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        const idx = y * size + x;
        if (safeCells.has(idx)) continue;
        if (board[y][x].mine) continue;

        // 1/3 ã®ç¢ºç‡ã§é‡çˆ†
        board[y][x].mine = Math.random() < 1/3 ? "heavy" : "normal";
        mines++;
      }

      // å‘¨å›²ã®åœ°é›·ã‚«ã‚¦ãƒ³ãƒˆ
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          let count = 0;
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              const nx = x + dx;
              const ny = y + dy;
              if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
                const mineType = board[ny][nx].mine;
                if (mineType === "normal") count += 1;
                else if (mineType === "heavy") count += 2;
              }
            }
          }
          board[y][x].count = count;
        }
      }
    }

    function openCell(cell) {
      if (cell.open) return;
      cell.open = true;
      openedCount++;
      cell.el.classList.add('open');

      if (cell.count > 0) {
        let displayCount = cell.count;
        if (Math.random() < DECEPTION_PROBABILITY) {
          displayCount = Math.max(1, cell.count - 1);
        }
        cell.el.textContent = displayCount;
        cell.el.style.color = getNumberColor(displayCount);
      }

      if (openedCount === size * size - mineCount) {
        endGame(true);
      }
    }

    function getNumberColor(n) {
      switch (n) {
        case 1: return '#1976d2';
        case 2: return '#388e3c';
        case 3: return '#d32f2f';
        case 4: return '#7b1fa2';
        case 5: return '#f57c00';
        case 6: return '#00796b';
        case 7: return '#000000';
        case 8: return '#7b1fa2';
        default: return '#000000';
      }
    }

    function openSurrounding(x, y) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            const neighbor = board[ny][nx];
            if (!neighbor.open && !neighbor.mine && !neighbor.flag) {
              openCell(neighbor);
              if (neighbor.count === 0) {
                openSurrounding(nx, ny);
              }
            }
          }
        }
      }
    }

    function endGame(win) {
      gameOver = true;
      clearInterval(timer);
      if (win) {
        statusEl.textContent = `ğŸ‰ å‹åˆ©ï¼ æ™‚é–“: ${timerSeconds}ç§’`;
      } else {
        statusEl.textContent = `ğŸ’¥ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼`;
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const cell = board[y][x];
            if (cell.mine && !cell.open) {
              cell.el.classList.add('mine');
              cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
            }
          }
        }
      }
    }

    init();
  </script>

  <!-- ãƒ­ã‚¸ãƒƒã‚¯ã‚½ãƒ«ãƒãƒ¼ï¼šæ•°å­—ã ã‘ã‹ã‚‰ {0,1,2} ã®å¯èƒ½é›†åˆã‚’çµã‚‹ï¼‹ä¸Šä½3å®‰å…¨ãƒã‚¹ -->
  <script>
  (function() {
    // ä½•å›ã€Œåˆ¶ç´„ä¼æ’­ã€ã‚’å›ã™ã‹ï¼ˆå¤§ããã™ã‚‹ã¨å°‘ã—ã ã‘å¼·ããªã‚‹ãŒã€ãã®åˆ†ã ã‘é‡ããªã‚‹ï¼‰
    const MAX_PROP_ITER = 10;

    // ãƒ’ãƒ³ãƒˆã®ã‚¯ãƒªã‚¢
    window.clearHints = function() {
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          c.el.classList.remove('logic-safe', 'logic-mine');
          if (!c.open && !c.flag) {
            c.el.textContent = '';
          }
          c.el.title = '';
        }
      }
    };

    // æ•°å­—ãƒã‚¹ï¼ˆopen & è¡¨ç¤ºã‚ã‚Š & >0ï¼‰ã‹ã‚‰åˆ¶ç´„ãƒªã‚¹ãƒˆã‚’ä½œã‚‹
    function getConstraints() {
      const constraints = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (!c.open) continue;
          if (!c.el.textContent) continue;

          const d = parseInt(c.el.textContent, 10);
          if (isNaN(d) || d <= 0) continue;

          const neighbors = [];
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              const nx = x + dx, ny = y + dy;
              if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
              neighbors.push(board[ny][nx]);
            }
          }
          constraints.push({ display: d, neighbors });
        }
      }
      return constraints;
    }

    // åˆ¶ç´„ã‹ã‚‰å„ãƒã‚¹ã®ã€Œ0/1/2 ã®å¯èƒ½ã“ã‚Œãã—ã‚‡ã‚“ã€ã‚’ä½œã‚‹
    function buildDomain(constraints) {
      const domain = [];
      for (let y = 0; y < size; y++) {
        domain[y] = [];
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (c.open) {
            // æ—¢ã«é–‹ã„ã¦ã„ã‚‹ãƒã‚¹ã¯ 0 å›ºå®š
            domain[y][x] = [true, false, false];
          } else if (c.flag) {
            // æ——ãŒç«‹ã£ã¦ã„ã‚‹ãƒã‚¹ã¯ã¨ã‚Šã‚ãˆãš 1 or 2 ã®å¯èƒ½æ€§ãŒã‚ã‚‹ã‚‚ã®ã¨ã™ã‚‹
            domain[y][x] = [false, true, true];
          } else {
            // ã¾ã æœªçŸ¥ã®ãƒã‚¹ï¼š0/1/2 ã™ã¹ã¦ã‚ã‚Šã†ã‚‹
            domain[y][x] = [true, true, true];
          }
        }
      }

      // åˆ¶ç´„ä¼æ’­
      for (let iter = 0; iter < MAX_PROP_ITER; iter++) {
        let changed = false;
        for (const cons of constraints) {
          const { display, neighbors } = cons;
          const unknownNeighbors = neighbors.filter(c => !c.open);

          // æ—¢ã«é–‹ã„ã¦ã„ã¦ã€ã‹ã¤åœ°é›·ã§ã¯ãªã„ãƒã‚¹ã¯0ç¢ºå®šãªã®ã§åˆ¶ç´„ã«ã¯é–¢ä¸ã—ãªã„
          // ï¼ˆãŸã ã—ã“ã“ã§ã¯ neighbors ã¯ã€Œå‘¨å›²ãƒã‚¹ã€ãªã®ã§ã€open ã§ã‚‚ count>0 ã‹ã‚‚ã—ã‚Œãªã„ãŒ
          //   åœ°é›·ã§ã¯ãªã„ã“ã¨ãŒç¢ºå®šã—ã¦ã„ã‚‹ã®ã§ 0 æ‰±ã„ï¼‰

          // unknownNeighbors ã«ã¤ã„ã¦ã€ãƒ‰ãƒ¡ã‚¤ãƒ³ã®åˆè¨ˆãŒ display ã‚’å®Ÿç¾ã§ãã‚‹ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
          const len = unknownNeighbors.length;
          if (len === 0) continue;

          // ç°¡æ˜“ã«ã€Œã‚ã‚Šå¾—ã‚‹ 0/1/2 ã®çµ„ã¿åˆã‚ã›ã€ã‚’å…¨éƒ¨å›ã™ï¼ˆæ·±ã•åˆ¶é™ä»˜ãï¼‰
          // ãŸã ã— len ãŒå¤§ãã™ãã‚‹ã¨çµ„åˆã›çˆ†ç™ºã™ã‚‹ã®ã§ã€ã‚ã‚‹ç¨‹åº¦ã§æ‰“ã¡åˆ‡ã‚‹
          if (len > 8) continue; // é©å½“ãªæ‰“ã¡åˆ‡ã‚Š

          // å„æœªçŸ¥ãƒã‚¹ã®ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’å‚ç…§
          const domList = unknownNeighbors.map(c => {
            const d = domain[c.y][c.x];
            return d;
          });

          const allowed = [false, false, false]; // 0/1/2 ã®ã©ã‚Œã‹ãŒã€Œã¾ã ã©ã“ã‹ã§ä½¿ãˆã‚‹ã‹ã€

          function dfs(idx, sum) {
            if (idx === len) {
              if (sum === display) {
                // ã“ã®çµ„ã¿åˆã‚ã›ã¯æœ‰åŠ¹
                for (let i = 0; i < len; i++) {
                  const d = domList[i];
                  for (let v = 0; v <= 2; v++) {
                    if (d[v]) allowed[v] = true;
                  }
                }
              }
              return;
            }
            const d = domList[idx];
            for (let v = 0; v <= 2; v++) {
              if (!d[v]) continue;
              // åˆè¨ˆãŒ display ã‚’æ˜ã‚‰ã‹ã«è¶…ãˆãŸã‚Šã€æ®‹ã‚Šãƒã‚¹ã‚’ãƒ•ãƒ«ã«ä½¿ã£ã¦ã‚‚ display ã«å±Šã‹ãªã„ãªã‚‰æåˆˆã‚Š
              const maxRest = (len - idx - 1) * 2;
              if (sum + v > display) continue;
              if (sum + v + maxRest < display) continue;
              dfs(idx + 1, sum + v);
            }
          }

          dfs(0, 0);

          // allowed ãŒã™ã¹ã¦ false ã«ãªã‚‹å ´åˆã¯ã€ã€Œã“ã®åˆ¶ç´„ã ã‘ã§ã¯çŸ›ç›¾ã€ã¨ã„ã†ã ã‘ãªã®ã§ã€
          // ã“ã“ã§ã¯ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’å£Šã•ãªã„
          if (!allowed[0] && !allowed[1] && !allowed[2]) {
            continue;
          }

          for (let v = 0; v <= 2; v++) {
            if (!allowed[v] && domList.some(d => d[v])) {
              for (let i = 0; i < len; i++) {
                if (domList[i][v]) {
                  domList[i][v] = false;
                  changed = true;
                }
              }
            }
          }
        }
        if (!changed) break;
      }

      return domain;
    }

    // ãƒ‰ãƒ¡ã‚¤ãƒ³ã‹ã‚‰ã€Œå®‰å…¨ç¢ºå®š / åœ°é›·ç¢ºå®šã€ã¨ã€Œã–ã£ãã‚Šå®‰å…¨ç¢ºç‡ã€ã‚’æ±‚ã‚ã‚‹
    function analyzeDomain(domain) {
      const safeKeys = [];
      const mineKeys = [];
      const safeProbMap = new Map();

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (c.open || c.flag) continue;

          const dom = domain[y][x];
          const key = `${x}_${y}`;

          const possible = [];
          for (let v = 0; v <= 2; v++) if (dom[v]) possible.push(v);

          if (possible.length === 0) {
            // çŸ›ç›¾ã—ã¦ã„ã‚‹ã ã‘ãªã®ã§ã€ã¨ã‚Šã‚ãˆãš 1/3 ã¨ã—ã¦ãŠã
            safeProbMap.set(key, 1/3);
            continue;
          }

          // å®‰å…¨ç¢ºå®š / åœ°é›·ç¢ºå®š
          const only0   = (possible.length === 1 && possible[0] === 0);
          const no0     = !dom[0] && (dom[1] || dom[2]); // 1 or 2 ã®ã¿

          if (only0) {
            safeKeys.push(key);
          } else if (no0) {
            mineKeys.push(key);
          }

          // ç°¡æ˜“ãªå®‰å…¨ç¢ºç‡ï¼šãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’ä¸€æ§˜åˆ†å¸ƒã¨ã¿ãªã™
          let mineVals = 0;
          for (const v of possible) if (v > 0) mineVals++;
          const safeProb = 1 - mineVals / possible.length;
          safeProbMap.set(key, safeProb);
        }
      }

      return { safeKeys, mineKeys, safeProbMap };
    }

    // ãƒ¡ã‚¤ãƒ³ï¼šè‡ªå‹•ãƒ’ãƒ³ãƒˆè¡¨ç¤º
    window.showHint = function() {
      if (gameOver) return;

      clearHints();

      const constraints = getConstraints();
      if (constraints.length === 0) {
        statusEl.textContent = 'ã¾ã æ•°å­—ãŒé–‹ã„ã¦ã„ãªã„ã®ã§ã€ä½•ã‚‚æ¨è«–ã§ãã¾ã›ã‚“ã€‚';
        return;
      }

      const domain = buildDomain(constraints);
      const { safeKeys, mineKeys, safeProbMap } = analyzeDomain(domain);

      let safeCount = 0;
      let mineCount = 0;

      // è‡ªå‹•ãƒ­ã‚¸ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰ã®ã¨ãã¯ã€ç¢ºå®šãƒã‚¹ã‚’å®Ÿéš›ã«é–‹ã‘ãŸã‚Šæ——ã‚’ç«‹ã¦ãŸã‚Šã™ã‚‹
      if (autoLogic) {
        let openedByLogic = 0;
        let flaggedByLogic = 0;

        for (const key of safeKeys) {
          const [xStr, yStr] = key.split('_');
          const x = Number(xStr), y = Number(yStr);
          const c = board[y][x];
          if (!c.open && !c.flag && !gameOver) {
            openCell(c);
            if (!gameOver && c.count === 0) {
              openSurrounding(x, y);
            }
            openedByLogic++;
          }
        }

        for (const key of mineKeys) {
          const [xStr, yStr] = key.split('_');
          const x = Number(xStr), y = Number(yStr);
          const c = board[y][x];
          if (!c.open && !c.flag && !gameOver) {
            c.flag = true;
            c.el.classList.add('flag');
            c.el.textContent = 'ğŸš©';
            flaggedByLogic++;
          }
        }

        if (openedByLogic === 0 && flaggedByLogic === 0) {
          statusEl.textContent =
            'è‡ªå‹•ãƒ­ã‚¸ãƒƒã‚¯ï¼šä»Šã®ã¨ã“ã‚ã€è«–ç†çš„ã«ç¢ºå®šã™ã‚‹ãƒã‚¹ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚';
        } else {
          statusEl.textContent =
            `è‡ªå‹•ãƒ­ã‚¸ãƒƒã‚¯ï¼šå®‰å…¨ãƒã‚¹ ${openedByLogic} ãƒã‚¹ã‚’é–‹ãã€` +
            `åœ°é›·ç¢ºå®šãƒã‚¹ ${flaggedByLogic} ãƒã‚¹ã«æ——ã‚’ç«‹ã¦ã¾ã—ãŸã€‚`;
        }

        // ãƒã‚¤ãƒ©ã‚¤ãƒˆã¯ä½¿ã‚ãªã„ã®ã§ã€ãã®ã¾ã¾çµ‚äº†
        return;
      }

      for (const key of safeKeys) {
        const [xStr, yStr] = key.split('_');
        const x = Number(xStr), y = Number(yStr);
        const c = board[y][x];
        c.el.classList.add('logic-safe');
        c.el.title = 'è«–ç†çš„ã«å®‰å…¨ãŒç¢ºå®šã—ã¦ã„ã¾ã™';
        safeCount++;
      }
      for (const key of mineKeys) {
        const [xStr, yStr] = key.split('_');
        const x = Number(xStr), y = Number(yStr);
        const c = board[y][x];
        c.el.classList.add('logic-mine');
        c.el.title = 'è«–ç†çš„ã«åœ°é›·ãŒç¢ºå®šã—ã¦ã„ã¾ã™ï¼ˆæ™®é€š or é‡çˆ†ï¼‰';
        mineCount++;
      }

      // ä¸€ã¤ã‚‚ç¢ºå®šã—ãªã‹ã£ãŸã‚‰ã€å®‰å…¨ãã†ãªä¸Šä½3ãƒã‚¹ã‚’è¡¨ç¤º
      if (safeCount === 0 && mineCount === 0) {
        const candidates = [];
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const c = board[y][x];
            if (c.open || c.flag) continue;
            const key = `${x}_${y}`;
            const p = safeProbMap.get(key);
            if (p == null) continue;
            candidates.push({ x, y, p });
          }
        }

        candidates.sort((a, b) => b.p - a.p);
        const top = candidates.slice(0, 3);

        for (const t of top) {
          const c = board[t.y][t.x];
          c.el.classList.add('logic-safe');
          c.el.textContent = `${Math.round(t.p * 100)}%`;
          c.el.title = `å®‰å…¨å€™è£œï¼ˆæ¨å®šå®‰å…¨ç¢ºç‡: ${(t.p * 100).toFixed(1)}%ï¼‰`;
        }

        statusEl.textContent =
          'åˆ¶ç´„ã‚’ ' + MAX_PROP_ITER + ' å›ä¼æ’­ã—ã¾ã—ãŸãŒã€\n' +
          'è«–ç†çš„ã« 100% å®‰å…¨ / 100% åœ°é›·ã«ãªã‚‹ãƒã‚¹ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\n' +
          'å®‰å…¨ãã†ãªå€™è£œ ä¸Šä½3ãƒã‚¹ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚';
      } else {
        statusEl.textContent =
          `è«–ç†çš„ã«å®‰å…¨ç¢ºå®š: ${safeCount} ãƒã‚¹\n` +
          `è«–ç†çš„ã«åœ°é›·ç¢ºå®š: ${mineCount} ãƒã‚¹`;
      }
    };
  })();
  </script>

</body>
</html>
