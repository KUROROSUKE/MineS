<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #f0f0f0;
      padding: 10px;
      user-select: none;
    }
    h1 {
      font-size: 24px;
      margin: 10px 0;
    }
    h2 {
      font-size: 14px;
      margin: 5px 0 15px;
      text-align: center;
      line-height: 1.6;
    }
    #controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    button {
      padding: 12px 24px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #2196f3;
      color: white;
    }
    #status {
      font-size: 18px;
      font-weight: bold;
      margin-top: 10px;
    }
    #board {
      display: grid;
      gap: 2px;
      box-sizing: border-box;
      margin: 0 auto;
      transition: all 0.2s ease-in-out;
    }
    .cell {
      background: #bbb;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      color: #333;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s;
      aspect-ratio: 1 / 1;
      user-select: none;
    }
    .cell.open {
      background: #e0e0e0;
    }
    .cell.flag {
      background: #ffeb3b;
      color: #d32f2f;
    }
    .cell.mine {
      background: #f44336;
      color: white;
    }
    .timer {
      font-size: 20px;
      font-weight: bold;
      margin-top: 10px;
    }

    /* å®‰å…¨ãƒã‚¹ï¼šå¤ªãã¦æ˜ã‚‹ã„æ ï¼‹èƒŒæ™¯ã‚‚å°‘ã—å¤‰ãˆã‚‹ */
    .cell.hint-safe {
      outline: 4px solid #00e676;
      outline-offset: -1px;
      background: #c8f7dc;
    }

    /* åœ°é›·ç¢ºå®šãƒã‚¹ï¼šèµ¤æ  */
    .cell.hint-mine {
      outline: 3px solid #d50000;
      outline-offset: -1px;
    }

    /* ä¸€ç•ªå®‰å…¨å€™è£œãƒã‚¹ï¼šé’ç‚¹ç·šæ  */
    .cell.hint-best {
      outline: 3px dashed #2962ff;
      outline-offset: -1px;
    }

    @media (max-width: 600px) {
      button {
        font-size: 16px;
        padding: 10px 20px;
      }
      h1 {
        font-size: 20px;
      }
      #status, .timer {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <h1>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</h1>
  <h2>
    1ãƒã‚¹ã§çˆ†å¼¾2å€‹åˆ†ã‚«ã‚¦ãƒ³ãƒˆã®é‡çˆ†å¼¾ãŒç´›ã‚Œè¾¼ã‚“ã§ã„ã‚‹ã€‚<br>
    ã¾ãŸã€æœ¬æ¥ã‚ˆã‚Š1å°‘ãªãè¡¨ç¤ºã•ã‚Œã‚‹å ´åˆãŒã‚ã‚‹ã€‚ï¼ˆæœ€å°å€¤1ï¼‰
  </h2>
  <div id="controls">
    <button id="resetButton">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
  </div>
  <div id="status"></div>
  <div id="board"></div>
  <div id="timer" class="timer">æ™‚é–“: 0</div>

  <script>
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const resetButton = document.getElementById('resetButton');
    const timerEl = document.getElementById('timer');

    const size = 20;
    const mineCount = 100;
    const DECEPTION_PROBABILITY = 0.5; // 50%ã§è¡¨ç¤ºæ•°å€¤ã‚’-1ï¼ˆãŸã ã—æœ€å°1ï¼‰

    let gameOver = false;
    let openedCount = 0;
    let board = [];
    let timer = null;
    let timerSeconds = 0;
    let firstClick = null; // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ä½ç½®ï¼ˆãã®å‘¨å›²ã¯å®‰å…¨ï¼‰

    resetButton.addEventListener('click', init);

    function init() {
      board = [];
      gameOver = false;
      openedCount = 0;
      firstClick = null;
      statusEl.textContent = '';
      boardEl.innerHTML = '';
      timerSeconds = 0;
      timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
      clearInterval(timer);
      timer = setInterval(() => {
        if (!gameOver) {
          timerSeconds++;
          timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
        }
      }, 1000);

      const shortSide = Math.min(window.innerWidth, window.innerHeight) * 0.9;
      boardEl.style.width = `${shortSide}px`;
      boardEl.style.height = `${shortSide}px`;
      boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      boardEl.style.gridTemplateRows = `repeat(${size}, 1fr)`;

      for (let y = 0; y < size; y++) {
        board[y] = [];
        for (let x = 0; x < size; x++) {
          const cellEl = document.createElement('div');
          cellEl.className = 'cell';
          cellEl.dataset.x = x;
          cellEl.dataset.y = y;
          boardEl.appendChild(cellEl);

          const cell = {
            x,
            y,
            mine: null,           // null / "normal" / "heavy"ï¼ˆå†…éƒ¨ç”¨ï¼‰
            open: false,
            flag: false,          // è‡ªå‹•ãƒ•ãƒ©ã‚°
            flagType: null,       // null / "unknown" / "normal" / "heavy"
            count: 0,             // çœŸã®ã‚«ã‚¦ãƒ³ãƒˆï¼ˆå†…éƒ¨ç”¨ï¼‰
            displayCount: null,   // ç”»é¢ä¸Šã®æ•°å­—ï¼ˆæ¬ºçè¾¼ã¿ï¼‰â€»æ¨è«–ã§ã¯ã“ã‚Œã ã‘ä½¿ç”¨
            hintStatus: null,     // null / "safe" / "mine"
            el: cellEl
          };
          board[y][x] = cell;

          cellEl.addEventListener('click', () => handleCellClick(cell));
        }
      }

      clearHintsAndFlags();
      // ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚ã¯æƒ…å ±ã‚¼ãƒ­ãªã®ã§ã€Œä¸€ç•ªå®‰å…¨ã€ã¯å®šç¾©ã§ããªã„ â‡’ ä½•ã‚‚å‡ºã•ãªã„
      updateHints();
    }

    function handleCellClick(cell) {
      if (gameOver || cell.open) return;
      if (cell.flag) return; // æ——ãŒç½®ã„ã¦ã‚ã‚‹ã¨ã“ã‚ã¯æŠ¼ã›ãªã„

      // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ã§åœ°é›·é…ç½®ï¼ˆãã®ãƒã‚¹ã¨å‘¨å›²3x3ã‚’å®‰å…¨ã«ï¼‰
      if (!firstClick) {
        firstClick = { x: cell.x, y: cell.y };
        placeMines();
      }

      openCell(cell);

      if (cell.mine) {
        cell.el.classList.add('mine');
        cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
        endGame(false);
        return;
      }

      if (cell.count === 0) {
        openSurrounding(cell.x, cell.y);
      }

      // æ“ä½œå¾Œã®çŠ¶æ…‹ã§æ¨è«–
      updateHints();

      if (openedCount === size * size - mineCount) {
        endGame(true);
      }
    }

    function placeMines() {
      let mines = 0;
      const safeCells = new Set();

      // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã¨ãã®å‘¨å›²3x3ã¯åœ°é›·ç¦æ­¢
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = firstClick.x + dx;
          const ny = firstClick.y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            safeCells.add(`${nx},${ny}`);
          }
        }
      }

      // é‡çˆ†å¼¾(2ã‚«ã‚¦ãƒ³ãƒˆ)ã®æ•°ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ±ºå®šï¼ˆã‚²ãƒ¼ãƒ å†…éƒ¨ç”¨ï¼‰
      const heavyMineCount = Math.floor(Math.random() * (mineCount + 1));
      let heavyMines = 0;

      while (mines < mineCount) {
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        const cell = board[y][x];

        if (!cell.mine && !safeCells.has(`${x},${y}`)) {
          if (heavyMines < heavyMineCount) {
            cell.mine = "heavy";
            heavyMines++;
          } else {
            cell.mine = "normal";
          }
          mines++;
        }
      }

      // åœ°é›·ä»¥å¤–ã®ãƒã‚¹ã®çœŸã®ã‚«ã‚¦ãƒ³ãƒˆï¼ˆå†…éƒ¨ç”¨ï¼‰
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.mine) continue;
          cell.count = getMineCount(x, y);
        }
      }
    }

    function getMineCount(x, y) {
      let count = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
          if (dx === 0 && dy === 0) continue;
          const neighbor = board[ny][nx];
          if (neighbor.mine === "normal") count += 1;
          else if (neighbor.mine === "heavy") count += 2;
        }
      }
      return count;
    }

    function openCell(cell) {
      if (cell.open || gameOver) return;
      cell.open = true;
      openedCount++;
      cell.el.classList.add('open');

      // é–‹ã„ãŸã‚»ãƒ«ä¸Šã®ãƒ•ãƒ©ã‚°ã¯æ¶ˆã™ï¼ˆä¿é™ºï¼‰
      if (cell.flag) {
        cell.flag = false;
        cell.flagType = null;
        cell.el.classList.remove('flag');
      }

      if (!cell.mine) {
        if (cell.count === 0) {
          cell.displayCount = 0;
          cell.el.textContent = '';
        } else {
          let displayCount = cell.count;
          if (Math.random() < DECEPTION_PROBABILITY) {
            displayCount = Math.max(1, cell.count - 1);
          }
          cell.displayCount = displayCount;   // æ¨è«–ã¯ã“ã‚Œã ã‘ã‚’è¦‹ã‚‹
          cell.el.textContent = displayCount;
          cell.el.style.color = getNumberColor(displayCount);
        }
      }
    }

    function getNumberColor(num) {
      switch (num) {
        case 1: return '#1976d2';
        case 2: return '#388e3c';
        case 3: return '#d32f2f';
        case 4: return '#7b1fa2';
        case 5: return '#f57c00';
        case 6: return '#00897b';
        case 7: return '#616161';
        case 8: return '#000000';
        default: return '#000000';
      }
    }

    function openSurrounding(x, y) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
          if (dx === 0 && dy === 0) continue;
          const neighbor = board[ny][nx];
          if (!neighbor.open && !neighbor.mine) {
            openCell(neighbor);
            if (neighbor.count === 0) {
              openSurrounding(nx, ny);
            }
          }
        }
      }
    }

    function endGame(win) {
      gameOver = true;
      clearInterval(timer);
      statusEl.textContent = win ? 'ã‚¯ãƒªã‚¢ï¼' : 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼';

      // åœ°é›·ã‚’å…¨è¡¨ç¤ºï¼ˆã‚²ãƒ¼ãƒ çµ‚äº†å¾Œã ã‘å†…éƒ¨æƒ…å ±ã‚’é–‹ç¤ºï¼‰
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.mine && !cell.open) {
            cell.el.classList.add('mine');
            cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
          }
        }
      }
    }

    // ---------- ãƒ’ãƒ³ãƒˆ & è‡ªå‹•ãƒ•ãƒ©ã‚°ï¼ˆè¡¨ç¤ºæƒ…å ±ã ã‘ã‚’ä½¿ç”¨ï¼‰ ----------

    function clearHintsAndFlags() {
      for (let y = 0; y < size; y++) {
        if (!board[y]) continue;
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (!c) continue;
          c.hintStatus = null;
          c.el.classList.remove('hint-safe', 'hint-mine', 'hint-best');
          // ãƒ•ãƒ©ã‚°ã¯æ¨è«–ã®ãŸã³ã«ä»˜ã‘ç›´ã™ã®ã§ä¸€æ—¦ãƒªã‚»ãƒƒãƒˆ
          if (!c.open) {
            c.flag = false;
            c.flagType = null;
            c.el.classList.remove('flag');
            c.el.textContent = '';
          }
        }
      }
    }

    function getNeighbors(x, y) {
      const res = [];
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            res.push(board[ny][nx]);
          }
        }
      }
      return res;
    }

    function markSafe(cell) {
      if (cell.hintStatus === "mine") return;
      cell.hintStatus = "safe";
      cell.el.classList.add('hint-safe');
    }

    function markMine(cell, mineType) {
      cell.hintStatus = "mine";
      cell.el.classList.add('hint-mine');

      // è‡ªå‹•ãƒ•ãƒ©ã‚°ä»˜ä¸ï¼ˆã‚ã‹ã‚‰ãªã„ï¼1ï¼2ï¼‰
      cell.flag = true;
      cell.flagType = mineType;
      cell.el.classList.add('flag');

      if (mineType === "normal") {
        cell.el.textContent = '1';
      } else if (mineType === "heavy") {
        cell.el.textContent = '2';
      } else {
        cell.el.textContent = 'ğŸš©?';
      }
    }

    function markBestCells(cells) {
      for (const cell of cells) {
        cell.el.classList.add('hint-best');
      }
    }

    // displayCount ã¨ã€Œ1å°ã•ã„å¯èƒ½æ€§ã€ã‚’è€ƒæ…®ã—ãŸåå¾©åˆ¶ç´„ä¼æ’­ï¼‹å±€æ‰€ SAT
    function updateHints() {
      clearHintsAndFlags();
      if (gameOver) return;

      // ã‚¹ã‚¿ãƒ¼ãƒˆå‰ï¼šæƒ…å ±ãŒãªã„ã®ã§ã€Œä¸€ç•ªå®‰å…¨ã€ã¯å®šç¾©ã—ãªã„
      if (!firstClick) return;

      // ===== 1. å…¨ãƒã‚¹ã®åˆæœŸ domain ã‚’ç”¨æ„ =====
      const poss = [];
      for (let y = 0; y < size; y++) {
        poss[y] = [];
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.open) {
            poss[y][x] = new Set([0]);
          } else {
            poss[y][x] = new Set([0, 1, 2]);
          }
        }
      }

      // ===== 2. æ•°å­—ã”ã¨ã®å±€æ‰€åˆ¶ç´„ã§ä½•å‘¨ã‹ domain ã‚’çµã‚‹ =====
      const MAX_LOCAL_ITER = 8;
      for (let iter = 0; iter < MAX_LOCAL_ITER; iter++) {
        let changed = false;

        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const cell = board[y][x];
            if (!cell.open) continue;

            const d = (cell.displayCount != null) ? cell.displayCount : 0;
            const neighbors = getNeighbors(x, y);
            const vars = neighbors.filter(n => !n.open);
            if (vars.length === 0) continue;

            let allowedSums;
            if (d === 0) {
              allowedSums = [0];
            } else {
              allowedSums = [d, d + 1];
            }

            const maxAllowed = Math.max(...allowedSums);

            const doms = [];
            let skip = false;
            for (const v of vars) {
              const s = poss[v.y][v.x];
              const domArr = [];
              if (s.has(0)) domArr.push(0);
              if (s.has(1)) domArr.push(1);
              if (s.has(2)) domArr.push(2);
              if (domArr.length === 0) {
                skip = true;
                break;
              }
              doms.push(domArr);
            }
            if (skip) continue;

            const localPossible = Array.from(
              { length: vars.length },
              () => new Set()
            );
            let anySolution = false;
            const cur = new Array(vars.length).fill(0);

            function dfsLocal(idx, sum) {
              if (sum > maxAllowed) return;
              if (idx === vars.length) {
                let ok = false;
                for (const a of allowedSums) {
                  if (sum === a) { ok = true; break; }
                }
                if (!ok) return;

                anySolution = true;
                for (let k = 0; k < vars.length; k++) {
                  localPossible[k].add(cur[k]);
                }
                return;
              }
              const domArr = doms[idx];
              for (const v of domArr) {
                cur[idx] = v;
                dfsLocal(idx + 1, sum + v);
              }
            }

            dfsLocal(0, 0);
            if (!anySolution) continue;

            for (let i = 0; i < vars.length; i++) {
              const vCell = vars[i];
              const oldSet = poss[vCell.y][vCell.x];
              const newSet = new Set();
              for (const val of oldSet) {
                if (localPossible[i].has(val)) newSet.add(val);
              }
              if (newSet.size === 0) continue;
              if (
                newSet.size !== oldSet.size ||
                [...newSet].some(val => !oldSet.has(val))
              ) {
                poss[vCell.y][vCell.x] = newSet;
                changed = true;
              }
            }
          }
        }

        if (!changed) break;
      }

      // ===== 3. ãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢ã‚’å¤‰æ•°åŒ–ã—ã¦å±€æ‰€ SAT ã‚’æ›ã‘ã‚‹ï¼ˆç¢ºç‡ã‚‚è¨ˆç®—ï¼‰ =====
      const idMap = Array.from({ length: size }, () =>
        Array(size).fill(-1)
      );
      const frontier = [];

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.open) continue;
          const neighbors = getNeighbors(x, y);
          let hasOpenNumber = false;
          for (const n of neighbors) {
            if (n.open && n.displayCount != null) {
              hasOpenNumber = true;
              break;
            }
          }
          if (hasOpenNumber) {
            idMap[y][x] = frontier.length;
            frontier.push(cell);
          }
        }
      }

      const F = frontier.length;

      // åˆ¶ç´„æ§‹ç¯‰
      const constraints = [];
      if (F > 0) {
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const cell = board[y][x];
            if (!cell.open) continue;

            const d = (cell.displayCount != null) ? cell.displayCount : 0;
            const neighbors = getNeighbors(x, y);
            const vars = [];
            for (const n of neighbors) {
              if (!n.open) {
                const vid = idMap[n.y][n.x];
                if (vid !== -1) vars.push(vid);
              }
            }
            if (vars.length === 0) continue;

            let allowedSums;
            if (d === 0) {
              allowedSums = [0];
            } else {
              allowedSums = [d, d + 1];
            }
            constraints.push({ vars, allowedSums });
          }
        }
      }

      const varPossible = Array.from({ length: F }, (_, i) => {
        const c = frontier[i];
        const s = poss[c.y][c.x];
        const ns = new Set();
        if (s.has(0)) ns.add(0);
        if (s.has(1)) ns.add(1);
        if (s.has(2)) ns.add(2);
        return ns;
      });

      const varRisk = Array(F).fill(null);
      const MAX_VARS_SAT = 18;

      if (F > 0 && constraints.length > 0) {
        const adj = Array.from({ length: F }, () => []);
        for (const c of constraints) {
          const vs = c.vars;
          for (let i = 0; i < vs.length; i++) {
            for (let j = i + 1; j < vs.length; j++) {
              const a = vs[i];
              const b = vs[j];
              adj[a].push(b);
              adj[b].push(a);
            }
          }
        }

        const visited = Array(F).fill(false);
        const components = [];
        for (let i = 0; i < F; i++) {
          if (visited[i]) continue;
          const queue = [i];
          visited[i] = true;
          const comp = [];
          while (queue.length > 0) {
            const v = queue.shift();
            comp.push(v);
            for (const nb of adj[v]) {
              if (!visited[nb]) {
                visited[nb] = true;
                queue.push(nb);
              }
            }
          }
          components.push(comp);
        }

        for (const comp of components) {
          const compSet = new Set(comp);
          const compIndexMap = new Map();
          comp.forEach((gid, idx) => compIndexMap.set(gid, idx));

          const compConstraints = [];
          for (const c of constraints) {
            const localVars = [];
            for (const vid of c.vars) {
              if (compSet.has(vid)) {
                localVars.push(compIndexMap.get(vid));
              }
            }
            if (localVars.length === 0) continue;
            compConstraints.push({
              vars: localVars,
              allowedSums: c.allowedSums
            });
          }

          const numVars = comp.length;
          const numCons = compConstraints.length;
          if (numVars === 0 || numCons === 0) continue;
          if (numVars > MAX_VARS_SAT) continue;

          const doms = [];
          let invalidComponent = false;
          for (let li = 0; li < numVars; li++) {
            const gid = comp[li];
            const s = varPossible[gid];
            const domArr = [];
            if (s.has(0)) domArr.push(0);
            if (s.has(1)) domArr.push(1);
            if (s.has(2)) domArr.push(2);
            if (domArr.length === 0) {
              invalidComponent = true;
              break;
            }
            doms.push(domArr);
          }
          if (invalidComponent) continue;

          const consSum = Array(numCons).fill(0);
          const consRemain = compConstraints.map(c => c.vars.length);

          const varCons = Array.from({ length: numVars }, () => []);
          for (let ci = 0; ci < numCons; ci++) {
            const vs = compConstraints[ci].vars;
            for (const v of vs) {
              varCons[v].push(ci);
            }
          }

          const compPossible = Array.from({ length: numVars }, () => new Set());
          const assign = Array(numVars).fill(0);
          let hasSolution = false;

          const freq = Array.from({ length: numVars }, () => [0, 0, 0]);
          let solutionCount = 0;

          function dfsVar(pos) {
            if (pos === numVars) {
              for (let ci = 0; ci < numCons; ci++) {
                const s = consSum[ci];
                const allowed = compConstraints[ci].allowedSums;
                let ok = false;
                for (const a of allowed) {
                  if (s === a) {
                    ok = true;
                    break;
                  }
                }
                if (!ok) return;
              }
              hasSolution = true;
              solutionCount++;
              for (let v = 0; v < numVars; v++) {
                const val = assign[v];
                compPossible[v].add(val);
                freq[v][val]++;
              }
              return;
            }

            const domArr = doms[pos];
            for (const val of domArr) {
              assign[pos] = val;
              let pruned = false;
              const touched = varCons[pos];
              for (const ci of touched) {
                consSum[ci] += val;
                consRemain[ci]--;

                const allowed = compConstraints[ci].allowedSums;
                const minTotal = consSum[ci];
                const maxTotal = consSum[ci] + consRemain[ci] * 2;

                let okRange = false;
                for (const a of allowed) {
                  if (a >= minTotal && a <= maxTotal) {
                    okRange = true;
                    break;
                  }
                }
                if (!okRange) {
                  pruned = true;
                }
              }

              if (!pruned) dfsVar(pos + 1);

              for (const ci of touched) {
                consSum[ci] -= val;
                consRemain[ci]++;
              }
            }
          }

          dfsVar(0);

          if (!hasSolution || solutionCount === 0) continue;

          for (let li = 0; li < numVars; li++) {
            const gid = comp[li];
            const pset = compPossible[li];
            if (pset.size > 0) varPossible[gid] = pset;

            const f = freq[li];
            const mineCountFreq = f[1] + f[2];
            const risk = mineCountFreq / solutionCount;
            varRisk[gid] = risk;
          }
        }

        // SAT ã§çµã‚ŒãŸ varPossible ã‚’ poss ã«åæ˜ 
        for (let i = 0; i < F; i++) {
          const cell = frontier[i];
          poss[cell.y][cell.x] = varPossible[i];
        }
      }

      // ===== 4. poss ã‚’å…ƒã«å®‰å…¨ï¼åœ°é›·ï¼‹è‡ªå‹•ãƒ•ãƒ©ã‚°ã‚’ä»˜ã‘ã‚‹ =====
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.open) continue;
          const s = poss[y][x];
          if (!s || s.size === 0) continue;

          const has0 = s.has(0);
          const has1 = s.has(1);
          const has2 = s.has(2);

          // å¸¸ã«0 â†’ å®‰å…¨ç¢ºå®š
          if (!has1 && !has2 && has0) {
            markSafe(cell);
          }

          // 0 ãŒã‚ã‚Šå¾—ãªã„ï¼ˆ1 or 2 ã®ã¿ï¼‰ â†’ åœ°é›·ç¢ºå®š
          if (!has0 && (has1 || has2)) {
            let type = "unknown";
            if (has1 && !has2) type = "normal";
            else if (!has1 && has2) type = "heavy";
            markMine(cell, type);
          }
        }
      }

      // ===== 5. å®‰å…¨ç¢ºå®šãƒã‚¹ã‚’è‡ªå‹•ã§é–‹ã â†’ æ–°ã—ãé–‹ã„ãŸã‚‰å†æ¨è«– =====
      const openedBefore = openedCount;

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (!cell.open && cell.hintStatus === "safe" && !cell.flag && !gameOver) {
            openCell(cell);
            if (cell.count === 0) {
              openSurrounding(cell.x, cell.y);
            }
          }
        }
      }

      if (!gameOver && openedCount > openedBefore) {
        updateHints(); // æ–°ã—ã„æƒ…å ±ã§å†æ¨è«–
        return;
      }

      // ===== 6. ç¢ºå®šå®‰å…¨ãŒãªããªã£ãŸã®ã§ã€ã€Œä¸€ç•ªåœ°é›·ãŒå°‘ãªãã†ãªãƒã‚¹ã€ã‚’å‡ºã™ =====
      let bestRisk = Infinity;
      const bestCells = [];

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.open || cell.flag) continue;

          const s = poss[y][x];
          if (!s) continue;

          const has0 = s.has(0);
          const has1 = s.has(1);
          const has2 = s.has(2);

          // domain ã‹ã‚‰ç°¡æ˜“ãƒªã‚¹ã‚¯ï¼ˆ0ã‚’å«ã¾ãªã„ãªã‚‰çµ¶å¯¾åœ°é›·ï¼‰
          let domainRisk;
          if (!has0 && (has1 || has2)) {
            domainRisk = 1.0;
          } else if (has0 && !has1 && !has2) {
            domainRisk = 0.0;
          } else {
            // 0,1,2 ã®ã†ã¡ã€Œåœ°é›·å€¤ã€ã®ç¨®é¡æ•° / ç·ç¨®é¡æ•° ã§ã–ã£ãã‚Š
            const mineKinds = (has1 ? 1 : 0) + (has2 ? 1 : 0);
            const totalKinds = (has0 ? 1 : 0) + mineKinds;
            domainRisk = mineKinds / totalKinds;
          }

          // ãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢ã§ SAT ã«ã‚ˆã‚‹ç¢ºç‡ãŒã‚ã‚Œã°ã€ãã‚Œã‚’å„ªå…ˆçš„ã«ä½¿ã†
          let risk = domainRisk;
          if (F > 0) {
            const id = idMap[y][x];
            if (id !== -1 && varRisk[id] != null) {
              risk = varRisk[id];
            }
          }

          if (risk < bestRisk - 1e-9) {
            bestRisk = risk;
            bestCells.length = 0;
            bestCells.push(cell);
          } else if (Math.abs(risk - bestRisk) < 1e-9) {
            bestCells.push(cell);
          }
        }
      }

      if (bestCells.length > 0 && bestRisk < Infinity) {
        markBestCells(bestCells);
      }
    }

    // åˆæœŸåŒ–
    init();
  </script>
</body>
</html>
