<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ãƒ­ã‚¸ãƒƒã‚¯ä»˜ããƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</title>
  <style>
    :root {
      --bg: #111827;
      --card-bg: #1f2933;
      --accent: #3b82f6;
      --accent-soft: #1d4ed8;
      --danger: #ef4444;
      --flag: #f59e0b;
      --cell-bg: #111827;
      --cell-bg-open: #0f172a;
      --cell-border: #374151;
      --text-main: #e5e7eb;
      --text-sub: #9ca3af;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: radial-gradient(circle at top, #1f2937 0, #020617 55%, #000 100%);
      color: var(--text-main);
      padding: 16px;
      user-select: none;
      min-height: 100vh;
    }

    h1 {
      font-size: 24px;
      margin: 4px 0 8px;
      letter-spacing: 0.05em;
    }

    h2 {
      font-size: 13px;
      font-weight: 400;
      margin: 0 0 12px;
      color: var(--text-sub);
      line-height: 1.6;
      text-align: left;
      max-width: 640px;
    }

    #shell {
      background: rgba(15, 23, 42, 0.92);
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      box-shadow:
        0 20px 45px rgba(15, 23, 42, 0.9),
        0 0 0 1px rgba(15, 23, 42, 0.8);
      padding: 16px 16px 20px;
      max-width: 720px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    #header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    #title-block {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    #subtitle {
      font-size: 12px;
      color: var(--text-sub);
    }

    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: flex-end;
    }

    button {
      padding: 6px 14px;
      font-size: 13px;
      border: none;
      border-radius: 999px;
      cursor: pointer;
      background: radial-gradient(circle at top left, var(--accent) 0, var(--accent-soft) 50%, #1e293b 100%);
      color: #e5e7eb;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow:
        0 0 0 1px rgba(59, 130, 246, 0.2),
        0 6px 16px rgba(15, 23, 42, 0.9);
      transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s ease;
      white-space: nowrap;
    }

    button span {
      font-size: 15px;
    }

    button:hover {
      filter: brightness(1.05);
      transform: translateY(-1px);
      box-shadow:
        0 0 0 1px rgba(59, 130, 246, 0.3),
        0 10px 24px rgba(15, 23, 42, 0.95);
    }

    button:active {
      transform: translateY(0);
      box-shadow:
        0 0 0 1px rgba(59, 130, 246, 0.4),
        0 4px 12px rgba(15, 23, 42, 0.9);
    }

    #info-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text-sub);
      flex-wrap: wrap;
    }

    #status {
      flex: 1;
      min-height: 1.4em;
      white-space: pre-line;
    }

    #timer {
      font-weight: 600;
      font-variant-numeric: tabular-nums;
    }

    #board-shell {
      background: radial-gradient(circle at top, #020617 0, #020617 55%, #000 100%);
      border-radius: 14px;
      padding: 10px;
      border: 1px solid rgba(31, 41, 55, 0.9);
      box-shadow:
        inset 0 0 24px rgba(15, 23, 42, 0.9),
        0 10px 35px rgba(0, 0, 0, 1);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #board {
      display: grid;
      gap: 1px;
      background: #020617;
      border-radius: 10px;
      overflow: hidden;
      touch-action: manipulation;
    }

    .cell {
      background: var(--cell-bg);
      border-radius: 4px;
      border: 1px solid var(--cell-border);
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      color: var(--text-main);
      transition: background 0.08s ease, transform 0.08s ease, box-shadow 0.08s ease, border-color 0.08s ease;
    }

    .cell:hover {
      background: #020617;
      transform: translateY(-0.5px);
      box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.4);
    }

    .cell.open {
      background: var(--cell-bg-open);
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    .cell.open:hover {
      box-shadow: none;
      transform: none;
    }

    .cell.mine {
      background: radial-gradient(circle at top, #f97373 0, var(--danger) 60%, #7f1d1d 100%);
      color: #fee2e2;
      border-color: #b91c1c;
      box-shadow: 0 0 10px rgba(239, 68, 68, 0.8);
    }

    .cell.flag {
      background: radial-gradient(circle at top, #fed7aa 0, var(--flag) 55%, #78350f 100%);
      color: #1f2933;
      border-color: #b45309;
      box-shadow: 0 0 8px rgba(245, 158, 11, 0.6);
    }

    .cell.logic-safe {
      box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.8);
      border-color: rgba(34, 197, 94, 0.6);
    }

    .cell.logic-mine {
      box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.9);
      border-color: rgba(239, 68, 68, 0.8);
    }

    @media (max-width: 640px) {
      #shell {
        padding: 12px;
      }
      h1 {
        font-size: 20px;
      }
      h2 {
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <div id="shell">
    <div id="header">
      <div id="title-block">
        <h1>ãƒ­ã‚¸ãƒƒã‚¯ä»˜ããƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</h1>
        <div id="subtitle">
          ãƒ»ä¸€éƒ¨ã®çˆ†å¼¾ã¯ã€Œé‡çˆ†å¼¾ã€ã§ã€å‘¨å›²ã« 2 å€‹åˆ†ã¨ã—ã¦æ•°ãˆä¸Šã’ã‚‰ã‚Œã‚‹ã€‚<br>
          ãƒ»è¡¨ç¤ºã•ã‚Œã‚‹æ•°å­—ã¯ã€æœ¬æ¥ã®åˆè¨ˆã‹ã‚‰ 1 å°‘ãªã„ã“ã¨ãŒã‚ã‚‹ï¼ˆãŸã ã— 1 æœªæº€ã«ã¯ãªã‚‰ãªã„ï¼‰ã€‚<br>
          ãƒ»æ•°å­—ãƒã‚¹ã ã‘ã‚’ä½¿ã£ã¦ã€0/1/2 ã®å…¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ·±ã•åˆ¶é™ä»˜ãã§ç·å½“ãŸã‚Šã—ã¦æ¨è«–ã€‚
        </div>
      </div>
      <div id="controls">
        <button id="flagButton">
          <span>ğŸš©</span> æ——ãƒ¢ãƒ¼ãƒ‰
        </button>
        <button id="resetButton">
          <span>ğŸ”„</span> ãƒªã‚»ãƒƒãƒˆ
        </button>
      </div>
    </div>

    <div id="info-row">
      <div id="status"></div>
      <div id="timer">æ™‚é–“: 0</div>
    </div>

    <div id="board-shell">
      <div id="board"></div>
    </div>
  </div>

  <!-- ã‚²ãƒ¼ãƒ æœ¬ä½“ -->
  <script>
    const boardEl   = document.getElementById('board');
    const statusEl  = document.getElementById('status');
    const flagButton  = document.getElementById('flagButton');
    const resetButton = document.getElementById('resetButton');
    const timerEl   = document.getElementById('timer');

    const size = 20;
    const mineCount = 100;          // çˆ†å¼¾ã®å€‹æ•°ï¼ˆé‡çˆ†ã‚‚ 1 å€‹ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆï¼‰
    const DECEPTION_PROBABILITY = 0.5; // 50%ã§è¡¨ç¤ºæ•°å€¤ã‚’-1ï¼ˆãŸã ã—æœ€å°1ï¼‰

    let gameOver    = false;
    let flagMode    = false;
    let openedCount = 0;
    let board       = [];
    let timer;
    let timerSeconds = 0;
    let firstClick  = null;

    flagButton.addEventListener('click', () => {
      flagMode = !flagMode;
      if (flagMode) {
        flagButton.style.background =
          "radial-gradient(circle at top left, #f59e0b 0, #d97706 50%, #1e293b 100%)";
        flagButton.style.boxShadow =
          "0 0 0 1px rgba(245, 158, 11, 0.35), 0 10px 24px rgba(15, 23, 42, 0.95)";
      } else {
        flagButton.style.background =
          "radial-gradient(circle at top left, #3b82f6 0, #1d4ed8 50%, #1e293b 100%)";
        flagButton.style.boxShadow =
          "0 0 0 1px rgba(59, 130, 246, 0.25), 0 6px 16px rgba(15, 23, 42, 0.9)";
      }
    });

    resetButton.addEventListener('click', init);

    function requestHint() {
      if (typeof showHint === 'function' && !gameOver) {
        showHint();
      }
    }

    function init() {
      board = [];
      gameOver = false;
      openedCount = 0;
      firstClick = null;
      statusEl.textContent = '';
      boardEl.innerHTML = '';
      timerSeconds = 0;
      timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
      clearInterval(timer);
      timer = setInterval(() => {
        if (!gameOver) {
          timerSeconds++;
          timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
        }
      }, 1000);

      // ãƒœãƒ¼ãƒ‰ã‚µã‚¤ã‚ºæ±ºå®š
      const maxBoardPx = Math.min(window.innerWidth, window.innerHeight) * 0.9;
      const boardSizePx = Math.min(maxBoardPx, 560);
      boardEl.style.width  = `${boardSizePx}px`;
      boardEl.style.height = `${boardSizePx}px`;
      boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      boardEl.style.gridTemplateRows    = `repeat(${size}, 1fr)`;

      for (let y = 0; y < size; y++) {
        board[y] = [];
        for (let x = 0; x < size; x++) {
          const cellEl = document.createElement('div');
          cellEl.className = 'cell';
          cellEl.dataset.x = x;
          cellEl.dataset.y = y;
          boardEl.appendChild(cellEl);

          const cell = {
            x,
            y,
            mine: null,   // null / "normal" / "heavy"
            open: false,
            flag: false,
            count: 0,
            el: cellEl
          };
          board[y][x] = cell;

          cellEl.addEventListener('click', () => handleCellClick(cell));
        }
      }

      if (typeof clearHints === 'function') clearHints();

      // æ——ãƒ¢ãƒ¼ãƒ‰åˆæœŸã‚¹ã‚¿ã‚¤ãƒ«
      flagMode = false;
      flagButton.style.background =
        "radial-gradient(circle at top left, #3b82f6 0, #1d4ed8 50%, #1e293b 100%)";
      flagButton.style.boxShadow =
        "0 0 0 1px rgba(59, 130, 246, 0.25), 0 6px 16px rgba(15, 23, 42, 0.9)";
    }

    function handleCellClick(cell) {
      if (gameOver) return;

      // æ——ãƒ¢ãƒ¼ãƒ‰ï¼šON ã®ã¨ãã¯æ——ã® ON/OFF ã ã‘
      if (flagMode) {
        if (!cell.open) {
          if (typeof clearHints === 'function') clearHints();
          cell.flag = !cell.flag;
          cell.el.classList.toggle('flag', cell.flag);
          cell.el.textContent = cell.flag ? 'ğŸš©' : '';
          requestHint();
        }
        return;
      }

      // é€šå¸¸ã‚¯ãƒªãƒƒã‚¯
      if (cell.open || cell.flag) return;
      if (typeof clearHints === 'function') clearHints();

      // åˆã‚¯ãƒªãƒƒã‚¯ã§åœ°é›·é…ç½®
      if (!firstClick) {
        firstClick = { x: cell.x, y: cell.y };
        placeMines();
      }

      // åœ°é›·ã‚’è¸ã‚“ã 
      if (cell.mine) {
        cell.el.classList.add('mine');
        cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
        endGame(false);
        return;
      }

      openCell(cell);

      if (cell.count === 0) {
        openSurrounding(cell.x, cell.y);
      }

      if (openedCount === size * size - mineCount) {
        endGame(true);
        return;
      }

      requestHint();
    }

    function placeMines() {
      let mines = 0;
      const safeCells = new Set();

      // åˆæ‰‹ã¨ãã®å‘¨å›²ã¯å®‰å…¨
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = firstClick.x + dx;
          const ny = firstClick.y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            safeCells.add(ny * size + nx);
          }
        }
      }

      while (mines < mineCount) {
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        const idx = y * size + x;
        if (safeCells.has(idx)) continue;
        if (board[y][x].mine) continue;

        // 1/3 ã®ç¢ºç‡ã§é‡çˆ†
        board[y][x].mine = Math.random() < 1/3 ? "heavy" : "normal";
        mines++;
      }

      // å‘¨å›²ã®åœ°é›·ã‚«ã‚¦ãƒ³ãƒˆ
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          let count = 0;
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              const nx = x + dx;
              const ny = y + dy;
              if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
                const mineType = board[ny][nx].mine;
                if (mineType === "normal") count += 1;
                else if (mineType === "heavy") count += 2;
              }
            }
          }
          board[y][x].count = count;
        }
      }
    }

    function openCell(cell) {
      if (cell.open) return;
      cell.open = true;
      openedCount++;
      cell.el.classList.add('open');

      if (cell.count > 0) {
        let displayCount = cell.count;
        if (Math.random() < DECEPTION_PROBABILITY) {
          displayCount = Math.max(1, cell.count - 1);
        }
        cell.el.textContent = displayCount;
        cell.el.style.color = getNumberColor(displayCount);
      } else {
        cell.el.textContent = '';
      }

      if (openedCount === size * size - mineCount) {
        endGame(true);
      }
    }

    function getNumberColor(n) {
      switch (n) {
        case 1: return '#60a5fa';
        case 2: return '#22c55e';
        case 3: return '#f97316';
        case 4: return '#a855f7';
        case 5: return '#ec4899';
        case 6: return '#06b6d4';
        case 7: return '#e5e7eb';
        case 8: return '#9ca3af';
        default: return '#e5e7eb';
      }
    }

    function openSurrounding(x, y) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            const neighbor = board[ny][nx];
            if (!neighbor.open && !neighbor.mine && !neighbor.flag) {
              openCell(neighbor);
              if (neighbor.count === 0) {
                openSurrounding(nx, ny);
              }
            }
          }
        }
      }
    }

    function endGame(win) {
      gameOver = true;
      clearInterval(timer);
      if (win) {
        statusEl.textContent = `ğŸ‰ ã‚¯ãƒªã‚¢ï¼ æ™‚é–“: ${timerSeconds}ç§’`;
      } else {
        statusEl.textContent = `ğŸ’¥ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼`;
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const cell = board[y][x];
            if (cell.mine && !cell.open) {
              cell.el.classList.add('mine');
              cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
            }
          }
        }
      }
    }

    init();
  </script>

  <!-- ãƒ­ã‚¸ãƒƒã‚¯ã‚½ãƒ«ãƒãƒ¼ï¼šæ•°å­—ã ã‘ã‹ã‚‰ {0,1,2} ã®å¯èƒ½é›†åˆã‚’çµã‚‹ï¼‹ä¸Šä½3å®‰å…¨ãƒã‚¹ -->
  <script>
  (function() {
    const MAX_PROP_ITER = 10;

    window.clearHints = function() {
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          c.el.classList.remove('logic-safe', 'logic-mine');
          if (!c.open && !c.flag) {
            c.el.textContent = '';
          }
          c.el.title = '';
        }
      }
    };

    function getConstraints() {
      const constraints = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (!c.open) continue;
          if (!c.el.textContent) continue;

          const d = parseInt(c.el.textContent, 10);
          if (isNaN(d) || d <= 0) continue;

          const neighbors = [];
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              const nx = x + dx, ny = y + dy;
              if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
              neighbors.push(board[ny][nx]);
            }
          }
          constraints.push({ display: d, neighbors });
        }
      }
      return constraints;
    }

    function buildDomain(constraints) {
      const domain = [];
      for (let y = 0; y < size; y++) {
        domain[y] = [];
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (c.open) {
            domain[y][x] = [true, false, false]; // 0å›ºå®š
          } else if (c.flag) {
            domain[y][x] = [false, true, true];  // 1 or 2
          } else {
            domain[y][x] = [true, true, true];   // 0/1/2 ã™ã¹ã¦
          }
        }
      }

      for (let iter = 0; iter < MAX_PROP_ITER; iter++) {
        let changed = false;
        for (const cons of constraints) {
          const { display, neighbors } = cons;
          const unknownNeighbors = neighbors.filter(c => !c.open);
          const len = unknownNeighbors.length;
          if (len === 0) continue;
          if (len > 8) continue; // çµ„åˆã›çˆ†ç™ºé˜²æ­¢

          const domList = unknownNeighbors.map(c => domain[c.y][c.x]);
          const allowed = [false, false, false];

          function dfs(idx, sum) {
            if (idx === len) {
              if (sum === display) {
                for (let i = 0; i < len; i++) {
                  const d = domList[i];
                  for (let v = 0; v <= 2; v++) {
                    if (d[v]) allowed[v] = true;
                  }
                }
              }
              return;
            }
            const d = domList[idx];
            for (let v = 0; v <= 2; v++) {
              if (!d[v]) continue;
              const maxRest = (len - idx - 1) * 2;
              if (sum + v > display) continue;
              if (sum + v + maxRest < display) continue;
              dfs(idx + 1, sum + v);
            }
          }

          dfs(0, 0);

          if (!allowed[0] && !allowed[1] && !allowed[2]) {
            continue;
          }

          for (let v = 0; v <= 2; v++) {
            if (!allowed[v] && domList.some(d => d[v])) {
              for (let i = 0; i < len; i++) {
                if (domList[i][v]) {
                  domList[i][v] = false;
                  changed = true;
                }
              }
            }
          }
        }
        if (!changed) break;
      }

      return domain;
    }

    function analyzeDomain(domain) {
      const safeKeys = [];
      const mineKeys = [];
      const safeProbMap = new Map();

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (c.open || c.flag) continue;

          const dom = domain[y][x];
          const key = `${x}_${y}`;

          const possible = [];
          for (let v = 0; v <= 2; v++) if (dom[v]) possible.push(v);

          if (possible.length === 0) {
            safeProbMap.set(key, 1/3);
            continue;
          }

          const only0   = (possible.length === 1 && possible[0] === 0);
          const no0     = !dom[0] && (dom[1] || dom[2]);

          if (only0) {
            safeKeys.push(key);
          } else if (no0) {
            mineKeys.push(key);
          }

          let mineVals = 0;
          for (const v of possible) if (v > 0) mineVals++;
          const safeProb = 1 - mineVals / possible.length;
          safeProbMap.set(key, safeProb);
        }
      }

      return { safeKeys, mineKeys, safeProbMap };
    }

    // ãƒ¡ã‚¤ãƒ³ï¼šæ¯æ‰‹ã”ã¨ã«å‘¼ã°ã‚Œã¦ã€è‡ªå‹•ã§ã€Œç¢ºå®šãƒã‚¹ã‚’é–‹ã‘ã‚‹ï¼æ——ã‚’ç«‹ã¦ã‚‹ã€
    window.showHint = function() {
      if (gameOver) return;

      clearHints();

      const constraints = getConstraints();
      if (constraints.length === 0) {
        statusEl.textContent = 'ã¾ã æ•°å­—ãŒã»ã¨ã‚“ã©é–‹ã„ã¦ã„ãªã„ã®ã§ã€æ¨è«–ã§ãã¾ã›ã‚“ã€‚';
        return;
      }

      const domain = buildDomain(constraints);
      const { safeKeys, mineKeys, safeProbMap } = analyzeDomain(domain);

      let openedByLogic = 0;
      let flaggedByLogic = 0;

      // å®‰å…¨ç¢ºå®šãƒã‚¹ã¯è‡ªå‹•ã§é–‹ã
      for (const key of safeKeys) {
        const [xStr, yStr] = key.split('_');
        const x = Number(xStr), y = Number(yStr);
        const c = board[y][x];
        if (!c.open && !c.flag && !gameOver && !c.mine) {
          openCell(c);
          if (!gameOver && c.count === 0) {
            openSurrounding(x, y);
          }
          openedByLogic++;
        }
      }

      // åœ°é›·ç¢ºå®šãƒã‚¹ã«ã¯è‡ªå‹•ã§æ——ã‚’ç«‹ã¦ã‚‹
      for (const key of mineKeys) {
        const [xStr, yStr] = key.split('_');
        const x = Number(xStr), y = Number(yStr);
        const c = board[y][x];
        if (!c.open && !c.flag && !gameOver) {
          c.flag = true;
          c.el.classList.add('flag');
          c.el.textContent = 'ğŸš©';
          flaggedByLogic++;
        }
      }

      // ä½•ã‚‚ç¢ºå®šã—ãªã„å ´åˆã¯ã€å®‰å…¨ãã†ãªå€™è£œã‚’ 3 ãƒã‚¹ã ã‘è¦‹ãŸç›®ã§æ•™ãˆã‚‹
      if (openedByLogic === 0 && flaggedByLogic === 0) {
        const candidates = [];
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const c = board[y][x];
            if (c.open || c.flag) continue;
            const key = `${x}_${y}`;
            const p = safeProbMap.get(key);
            if (p == null) continue;
            candidates.push({ x, y, p });
          }
        }

        candidates.sort((a, b) => b.p - a.p);
        const top = candidates.slice(0, 3);

        for (const t of top) {
          const c = board[t.y][t.x];
          c.el.classList.add('logic-safe');
          c.el.textContent = `${Math.round(t.p * 100)}%`;
          c.el.title = `å®‰å…¨å€™è£œï¼ˆæ¨å®šå®‰å…¨ç¢ºç‡: ${(t.p * 100).toFixed(1)}%ï¼‰`;
        }

        statusEl.textContent =
          'è«–ç†çš„ã« 100% ç¢ºå®šã™ã‚‹ãƒã‚¹ã¯ãªã—ã€‚\n' +
          'å®‰å…¨å€™è£œã®ä¸Šä½ 3 ãƒã‚¹ã‚’ç›®å°ã ã‘è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚';
      } else {
        statusEl.textContent =
          `è‡ªå‹•ãƒ­ã‚¸ãƒƒã‚¯: å®‰å…¨ãƒã‚¹ ${openedByLogic} ãƒã‚¹ã‚’é–‹ãã€` +
          `åœ°é›·ç¢ºå®šãƒã‚¹ ${flaggedByLogic} ãƒã‚¹ã«æ——ã‚’ç«‹ã¦ã¾ã—ãŸã€‚`;
      }
    };
  })();
  </script>
</body>
</html>
