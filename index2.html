<!-- ロジックソルバー：数字だけから {0,1,2} の可能集合を絞る＋上位3安全マス -->
<script>
(function() {
  // 何回「制約伝播」を回すか（大きくすると少しだけ強くなるが、その分だけ重くなる）
  const MAX_PROP_ITER = 10;

  // ヒントのクリア
  window.clearHints = function() {
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const c = board[y][x];
        c.el.classList.remove('logic-safe', 'logic-mine');
        if (!c.open && !c.flag) {
          c.el.textContent = '';
        }
        c.el.title = '';
      }
    }
  };

  // 数字マス（open & 表示あり & >0）から制約リストを作る
  function getConstraints() {
    const constraints = [];
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const c = board[y][x];
        if (!c.open) continue;
        if (!c.el.textContent) continue;

        const d = parseInt(c.el.textContent, 10);
        if (isNaN(d) || d <= 0) continue;

        const neighbors = [];
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx, ny = y + dy;
            if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
            neighbors.push(board[ny][nx]);
          }
        }
        constraints.push({ display: d, neighbors });
      }
    }
    return constraints;
  }

  // 各マスのドメイン domain[y][x] = [can0, can1, can2]
  function initDomains() {
    const domain = [];
    for (let y = 0; y < size; y++) {
      domain[y] = [];
      for (let x = 0; x < size; x++) {
        const c = board[y][x];
        if (c.open) {
          // 開いているマスは必ず安全（0）
          domain[y][x] = [true, false, false];
        } else {
          // 閉じているマスは 0,1,2 すべてあり得る
          domain[y][x] = [true, true, true];
        }
      }
    }
    return domain;
  }

  // 1 つの制約 cons で、各 neighbor のドメインを削る
  function propagateConstraint(cons, domain) {
    let changed = false;
    const d = cons.display;

    // 事前に neighbors ごとの min/max を計算しておく
    const mins = [];
    const maxs = [];
    for (let i = 0; i < cons.neighbors.length; i++) {
      const c = cons.neighbors[i];
      const dom = domain[c.y][c.x];
      const vals = [];
      for (let v = 0; v <= 2; v++) if (dom[v]) vals.push(v);
      if (vals.length === 0) {
        // すでに矛盾しているが、ここでは何もしない
        mins[i] = 0;
        maxs[i] = 0;
      } else {
        mins[i] = Math.min(...vals);
        maxs[i] = Math.max(...vals);
      }
    }

    for (let idx = 0; idx < cons.neighbors.length; idx++) {
      const c = cons.neighbors[idx];
      const dom = domain[c.y][c.x];

      // もともとの候補を覚えておく
      const original = dom.slice();
      const allowed = [false, false, false];

      for (let v = 0; v <= 2; v++) {
        if (!original[v]) continue;

        // このセルを v としたときに、他が何かしらの値を取って
        // 合計 S ∈ {d, d+1} を作れるかどうかをチェック
        let feasible = false;

        // 他のセルの min/max
        let otherMin = 0;
        let otherMax = 0;
        for (let j = 0; j < cons.neighbors.length; j++) {
          if (j === idx) continue;
          otherMin += mins[j];
          otherMax += maxs[j];
        }

        for (const S of [d, d + 1]) {
          // S からこのセルの v を引いた残りを、他のセルで作れるか？
          const rest = S - v;
          if (rest < otherMin || rest > otherMax) {
            continue; // この S では無理
          }
          // 他のセルの値は 0/1/2 のレンジなので、
          // 「rest が [otherMin, otherMax] に入っている」なら
          // 何かしらの組み合わせはある、とみなす（過小ではなく過大評価）
          feasible = true;
          break;
        }

        if (feasible) {
          allowed[v] = true;
        }
      }

      // allowed がすべて false になる場合は、「この制約だけでは矛盾」というだけなので、
      // ここではドメインを壊さない
      if (!allowed[0] && !allowed[1] && !allowed[2]) {
        continue;
      }

      for (let v = 0; v <= 2; v++) {
        if (!allowed[v] && dom[v]) {
          dom[v] = false;
          changed = true;
        }
      }
    }

    return changed;
  }

  // 制約全体を MAX_PROP_ITER 回まで回してドメインを収束させる
  function propagateAll(constraints, domain) {
    let changed = true;
    let iter = 0;
    while (changed && iter < MAX_PROP_ITER) {
      changed = false;
      iter++;
      for (const cons of constraints) {
        if (propagateConstraint(cons, domain)) {
          changed = true;
        }
      }
    }
  }

  // メイン：自動ヒント表示
  window.showHint = function() {
    if (gameOver) return;

    clearHints();

    const constraints = getConstraints();
    if (constraints.length === 0) {
      statusEl.textContent = 'まだ数字が開いていないので、何も推論できません。';
      return;
    }

    const domain = initDomains();
    propagateAll(constraints, domain);

    // 各セルの「安全確定 / 地雷確定」を判定
    const safeKeys = [];
    const mineKeys = [];
    const safeProbMap = new Map(); // key => safeProb（上位3用）

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const c = board[y][x];
        if (c.open || c.flag) continue;

        const dom = domain[y][x];
        const key = `${x}_${y}`;

        const possible = [];
        for (let v = 0; v <= 2; v++) if (dom[v]) possible.push(v);

        if (possible.length === 0) {
          // 矛盾しているだけなので、とりあえず 1/3 としておく
          safeProbMap.set(key, 1/3);
          continue;
        }

        // 安全確定 / 地雷確定
        const only0   = (possible.length === 1 && possible[0] === 0);
        const no0     = !dom[0] && (dom[1] || dom[2]); // 1 or 2 のみ

        if (only0) {
          safeKeys.push(key);
        } else if (no0) {
          mineKeys.push(key);
        }

        // 簡易な安全確率：ドメインを一様分布とみなす
        let mineVals = 0;
        for (const v of possible) if (v > 0) mineVals++;
        const safeProb = 1 - mineVals / possible.length;
        safeProbMap.set(key, safeProb);
      }
    }

    // まず「論理的に 100%」のマスをマーク
    let safeCount = 0;
    let mineCount = 0;

    for (const key of safeKeys) {
      const [xStr, yStr] = key.split('_');
      const x = Number(xStr), y = Number(yStr);
      const c = board[y][x];
      c.el.classList.add('logic-safe');
      c.el.title = '論理的に安全が確定しています';
      safeCount++;
    }
    for (const key of mineKeys) {
      const [xStr, yStr] = key.split('_');
      const x = Number(xStr), y = Number(yStr);
      const c = board[y][x];
      c.el.classList.add('logic-mine');
      c.el.title = '論理的に地雷が確定しています（普通 or 重爆）';
      mineCount++;
    }

    // 一つも確定しなかったら、安全そうな上位3マスを表示
    if (safeCount === 0 && mineCount === 0) {
      const candidates = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (c.open || c.flag) continue;
          const key = `${x}_${y}`;
          const p = safeProbMap.get(key);
          if (p == null) continue;
          candidates.push({ x, y, p });
        }
      }

      candidates.sort((a, b) => b.p - a.p);
      const top = candidates.slice(0, 3);

      for (const t of top) {
        const c = board[t.y][t.x];
        c.el.classList.add('logic-safe');
        c.el.textContent = `${Math.round(t.p * 100)}%`;
        c.el.title = `安全候補（推定安全確率: ${(t.p * 100).toFixed(1)}%）`;
      }

      statusEl.textContent =
        '制約を ' + MAX_PROP_ITER + ' 回伝播しましたが、\n' +
        '論理的に 100% 安全 / 100% 地雷になるマスはありませんでした。\n' +
        '安全そうな候補 上位3マスを表示しています。';
    } else {
      statusEl.textContent =
        `論理的に安全確定: ${safeCount} マス\n` +
        `論理的に地雷確定: ${mineCount} マス`;
    }
  };
})();
</script>
