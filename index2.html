<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #f0f0f0;
      padding: 10px;
      user-select: none;
    }
    h1 {
      font-size: 24px;
      margin: 10px 0;
    }
    h2 {
      font-size: 14px;
      margin: 5px 0 15px;
      text-align: center;
      line-height: 1.6;
    }
    #controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    button {
      padding: 12px 24px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #2196f3;
      color: white;
    }
    #status {
      font-size: 18px;
      font-weight: bold;
      margin-top: 10px;
    }
    #board {
      display: grid;
      gap: 2px;
      box-sizing: border-box;
      margin: 0 auto;
      transition: all 0.2s ease-in-out;
    }
    .cell {
      background: #bbb;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      color: #333;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s;
      aspect-ratio: 1 / 1;
      user-select: none;
    }
    .cell.open {
      background: #e0e0e0;
    }
    .cell.flag {
      background: #ffeb3b;
      color: #d32f2f;
    }
    .cell.mine {
      background: #f44336;
      color: white;
    }
    .timer {
      font-size: 20px;
      font-weight: bold;
      margin-top: 10px;
    }

    /* ãƒ’ãƒ³ãƒˆç”¨ï¼šå…ƒã®è‰²ã‚’å¤‰ãˆãšå¤–æ ã ã‘è¡¨ç¤º */
    .cell.hint-safe {
      outline: 2px solid #00c853; /* ç·‘ */
      outline-offset: -2px;
    }
    .cell.hint-mine {
      outline: 2px solid #d50000; /* èµ¤ */
      outline-offset: -2px;
    }

    @media (max-width: 600px) {
      button {
        font-size: 16px;
        padding: 10px 20px;
      }
      h1 {
        font-size: 20px;
      }
      #status, .timer {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <h1>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</h1>
  <h2>
    1ãƒã‚¹ã§çˆ†å¼¾2å€‹åˆ†ã‚«ã‚¦ãƒ³ãƒˆã®é‡çˆ†å¼¾ãŒç´›ã‚Œè¾¼ã‚“ã§ã„ã‚‹ã€‚<br>
    ã¾ãŸã€æœ¬æ¥ã‚ˆã‚Š1å°‘ãªãè¡¨ç¤ºã•ã‚Œã‚‹å ´åˆãŒã‚ã‚‹ã€‚ï¼ˆæœ€å°å€¤1ï¼‰
  </h2>
  <div id="controls">
    <button id="resetButton">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
  </div>
  <div id="status"></div>
  <div id="board"></div>
  <div id="timer" class="timer">æ™‚é–“: 0</div>

  <script>
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const resetButton = document.getElementById('resetButton');
    const timerEl = document.getElementById('timer');

    const size = 20;
    const mineCount = 100;
    const DECEPTION_PROBABILITY = 0.5; // 50%ã§è¡¨ç¤ºæ•°å€¤ã‚’-1ï¼ˆãŸã ã—æœ€å°1ï¼‰

    let gameOver = false;
    let openedCount = 0;
    let board = [];
    let timer = null;
    let timerSeconds = 0;
    let firstClick = null; // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ä½ç½®ï¼ˆãã®å‘¨å›²ã¯å®‰å…¨ï¼‰

    resetButton.addEventListener('click', init);

    function init() {
      board = [];
      gameOver = false;
      openedCount = 0;
      firstClick = null;
      statusEl.textContent = '';
      boardEl.innerHTML = '';
      timerSeconds = 0;
      timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
      clearInterval(timer);
      timer = setInterval(() => {
        if (!gameOver) {
          timerSeconds++;
          timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
        }
      }, 1000);

      const shortSide = Math.min(window.innerWidth, window.innerHeight) * 0.9;
      boardEl.style.width = `${shortSide}px`;
      boardEl.style.height = `${shortSide}px`;
      boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      boardEl.style.gridTemplateRows = `repeat(${size}, 1fr)`;

      for (let y = 0; y < size; y++) {
        board[y] = [];
        for (let x = 0; x < size; x++) {
          const cellEl = document.createElement('div');
          cellEl.className = 'cell';
          cellEl.dataset.x = x;
          cellEl.dataset.y = y;
          boardEl.appendChild(cellEl);

          const cell = {
            x,
            y,
            mine: null,           // null / "normal" / "heavy"ï¼ˆå†…éƒ¨ç”¨ã€‚æ¨è«–ã§ã¯ä½¿ã‚ãªã„ï¼‰
            open: false,
            flag: false,          // è‡ªå‹•ãƒ•ãƒ©ã‚°
            flagType: null,       // null / "unknown" / "normal" / "heavy"
            count: 0,             // çœŸã®ã‚«ã‚¦ãƒ³ãƒˆï¼ˆå†…éƒ¨ç”¨ï¼‰
            displayCount: null,   // ç”»é¢ä¸Šã®æ•°å­—ï¼ˆæ¬ºçè¾¼ã¿ï¼‰â€»æ¨è«–ã¯ã“ã‚Œã ã‘ä½¿ç”¨
            hintStatus: null,     // null / "safe" / "mine"
            domain: new Set([0, 1, 2]), // ã“ã®ãƒã‚¹ãŒå–ã‚Šã†ã‚‹å€¤ã®é›†åˆï¼ˆ0/1/2ï¼‰
            el: cellEl
          };
          board[y][x] = cell;

          cellEl.addEventListener('click', () => handleCellClick(cell));
        }
      }

      clearHintsOnly();
    }

    function handleCellClick(cell) {
      if (gameOver || cell.open) return;

      // æ——ãŒç½®ã„ã¦ã‚ã‚‹ã¨ã“ã‚ã¯æŠ¼ã›ãªã„
      if (cell.flag) return;

      // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ã§åœ°é›·é…ç½®ï¼ˆãã®ãƒã‚¹ã¨å‘¨å›²3x3ã‚’å®‰å…¨ã«ï¼‰
      if (!firstClick) {
        firstClick = { x: cell.x, y: cell.y };
        placeMines();
      }

      openCell(cell);

      if (cell.mine) {
        cell.el.classList.add('mine');
        cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
        endGame(false);
        return;
      }

      if (cell.count === 0) {
        openSurrounding(cell.x, cell.y);
      }

      updateHints(); // è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹æƒ…å ±ã ã‘ã‹ã‚‰æ¨è«–

      if (openedCount === size * size - mineCount) {
        endGame(true);
      }
    }

    function placeMines() {
      let mines = 0;
      const safeCells = new Set();

      // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã¨ãã®å‘¨å›²3x3ã¯åœ°é›·ç¦æ­¢
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = firstClick.x + dx;
          const ny = firstClick.y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            safeCells.add(`${nx},${ny}`);
          }
        }
      }

      // é‡çˆ†å¼¾(2ã‚«ã‚¦ãƒ³ãƒˆ)ã®æ•°ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ±ºå®š
      const heavyMineCount = Math.floor(Math.random() * (mineCount + 1));
      let heavyMines = 0;

      while (mines < mineCount) {
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        const cell = board[y][x];

        if (!cell.mine && !safeCells.has(`${x},${y}`)) {
          if (heavyMines < heavyMineCount) {
            cell.mine = "heavy";
            heavyMines++;
          } else {
            cell.mine = "normal";
          }
          mines++;
        }
      }

      // åœ°é›·ä»¥å¤–ã®ãƒã‚¹ã®çœŸã®ã‚«ã‚¦ãƒ³ãƒˆï¼ˆå†…éƒ¨ç”¨ï¼‰
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.mine) continue;
          cell.count = getMineCount(x, y);
        }
      }
    }

    function getMineCount(x, y) {
      let count = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
          if (dx === 0 && dy === 0) continue;
          const neighbor = board[ny][nx];
          if (neighbor.mine === "normal") count += 1;
          else if (neighbor.mine === "heavy") count += 2;
        }
      }
      return count;
    }

    function openCell(cell) {
      if (cell.open || gameOver) return;
      cell.open = true;
      openedCount++;
      cell.el.classList.add('open');

      // é–‹ã„ãŸã‚»ãƒ«ä¸Šã®ãƒ•ãƒ©ã‚°ã¯æ¶ˆã™ï¼ˆä¿é™ºï¼‰
      if (cell.flag) {
        cell.flag = false;
        cell.flagType = null;
        cell.el.classList.remove('flag');
      }

      // é–‹ã„ãŸãƒã‚¹ã® domain ã¯ 0 ã«å›ºå®š
      cell.domain = new Set([0]);

      if (!cell.mine) {
        if (cell.count === 0) {
          // 0 ã®ã¨ãã¯è¡¨ç¤ºã—ãªã„ãŒã€displayCount ã«ã¯ 0 ã‚’å…¥ã‚Œã¦ãŠã
          cell.displayCount = 0;
          cell.el.textContent = '';
        } else {
          let displayCount = cell.count;
          if (Math.random() < DECEPTION_PROBABILITY) {
            displayCount = Math.max(1, cell.count - 1);
          }
          cell.displayCount = displayCount;   // â˜… æ¨è«–ã¯ã“ã‚Œã ã‘ã‚’è¦‹ã‚‹
          cell.el.textContent = displayCount;
          cell.el.style.color = getNumberColor(displayCount);
        }
      }
    }

    function getNumberColor(num) {
      switch (num) {
        case 1: return '#1976d2';
        case 2: return '#388e3c';
        case 3: return '#d32f2f';
        case 4: return '#7b1fa2';
        case 5: return '#f57c00';
        case 6: return '#00897b';
        case 7: return '#616161';
        case 8: return '#000000';
        default: return '#000000';
      }
    }

    function openSurrounding(x, y) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
          if (dx === 0 && dy === 0) continue;
          const neighbor = board[ny][nx];
          if (!neighbor.open && !neighbor.mine) {
            openCell(neighbor);
            if (neighbor.count === 0) {
              openSurrounding(nx, ny);
            }
          }
        }
      }
    }

    function endGame(win) {
      gameOver = true;
      clearInterval(timer);
      statusEl.textContent = win ? 'ã‚¯ãƒªã‚¢ï¼' : 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼';

      // åœ°é›·ã‚’å…¨è¡¨ç¤ºï¼ˆã‚²ãƒ¼ãƒ çµ‚äº†å¾Œã ã‘å†…éƒ¨æƒ…å ±ã‚’é–‹ç¤ºï¼‰
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.mine && !cell.open) {
            cell.el.classList.add('mine');
            cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
          }
        }
      }
    }

    // ---------- ãƒ’ãƒ³ãƒˆ & è‡ªå‹•ãƒ•ãƒ©ã‚° ----------

    function clearHintsOnly() {
      for (let y = 0; y < size; y++) {
        if (!board[y]) continue;
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (!c) continue;
          c.hintStatus = null;
          c.el.classList.remove('hint-safe', 'hint-mine');
        }
      }
    }

    function getNeighbors(x, y) {
      const res = [];
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            res.push(board[ny][nx]);
          }
        }
      }
      return res;
    }

    // domain ã¨ newSet ã® intersectionã€‚å¤‰åŒ–ãŒã‚ã‚Œã° true ã‚’è¿”ã™
    function intersectDomain(domain, newSet) {
      let changed = false;
      for (const v of [0, 1, 2]) {
        if (domain.has(v) && !newSet.has(v)) {
          domain.delete(v);
          changed = true;
        }
      }
      return changed;
    }

    // displayCount ã¨ã€Œ1å°ã•ã„å¯èƒ½æ€§ã€ã‚’è€ƒæ…®ã—ãŸåå¾©åˆ¶ç´„ä¼æ’­
    // - å„ãƒã‚¹ cell.domain ã¯å‰å›ã¾ã§ã®æƒ…å ±ã‚’ä¿æŒï¼ˆ0/1/2 ã®ã©ã‚ŒãŒã‚ã‚Šå¾—ã‚‹ã‹ï¼‰
    // - å„æ•°å­—ãƒã‚¹ã®ã€Œå‘¨å›²åˆè¨ˆ âˆˆ {d, d+1}ã€åˆ¶ç´„ã‚’ä½•åº¦ã‚‚ã‹ã‘ã¦ domain ã‚’ç‹­ã‚ã‚‹
    function updateHints() {
      clearHintsOnly();
      if (!firstClick) return;

      // 1. domain ã®åˆæœŸåŒ–ï¼è£œæ­£
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];

          // é–‹ã„ã¦ã„ã‚‹ãƒã‚¹ã¯å¿…ãš0
          if (cell.open) {
            cell.domain = new Set([0]);
            continue;
          }

          // ã¾ã  domain ãŒãªã„å ´åˆï¼ˆåˆå›ãªã©ï¼‰ã¯ {0,1,2} ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ
          if (!cell.domain) {
            cell.domain = new Set([0, 1, 2]);
          }

          // æ——ã®ç¨®é¡ãŒç¢ºå®šã—ã¦ã„ã‚Œã°ã€domain ã‚’ãã‚Œã«åˆã‚ã›ã‚‹
          if (cell.flagType === "normal") {
            cell.domain = new Set([1]);
          } else if (cell.flagType === "heavy") {
            cell.domain = new Set([2]);
          } else if (cell.flagType === "unknown" && cell.flag) {
            cell.domain = new Set([1, 2]);
          }
        }
      }

      // 2. åå¾©åˆ¶ç´„ä¼æ’­
      const MAX_ITER = 8;
      for (let iter = 0; iter < MAX_ITER; iter++) {
        let changed = false;

        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const cell = board[y][x];
            if (!cell.open) continue;

            const d = (cell.displayCount != null) ? cell.displayCount : 0;
            const neighbors = getNeighbors(x, y);
            const targets = neighbors.filter(n => !n.open); // æœªã‚ªãƒ¼ãƒ—ãƒ³ã®ã¿å¤‰æ•°ã¨ã—ã¦æ‰±ã†

            if (targets.length === 0) continue;

            let allowedSums;
            if (d === 0) {
              allowedSums = [0];           // è¡¨ç¤º0 â†’ åˆè¨ˆ0å›ºå®š
            } else {
              allowedSums = [d, d + 1];    // è¡¨ç¤ºd â†’ æœ¬å½“ã®åˆè¨ˆã¯ d ã‹ d+1
            }

            // å„ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ç¾åœ¨ã® domain ã‚’é…åˆ—ã¨ã—ã¦ã‚³ãƒ”ãƒ¼
            const doms = [];
            for (const t of targets) {
              const s = t.domain;
              const domArr = [];
              if (s.has(0)) domArr.push(0);
              if (s.has(1)) domArr.push(1);
              if (s.has(2)) domArr.push(2);
              if (domArr.length === 0) {
                // çŸ›ç›¾ã—ã¦ã„ã‚‹å ´åˆã€ã“ã®æ•°å­—ã‹ã‚‰ã¯ä½•ã‚‚çµã‚Œãªã„
                continue;
              }
              doms.push(domArr);
            }

            const localPossible = Array.from({ length: targets.length }, () => new Set());
            let anySolution = false;
            const maxAllowed = Math.max(...allowedSums);
            const cur = new Array(targets.length).fill(0);

            function dfs(idx, sum) {
              if (sum > maxAllowed) return;
              if (idx === targets.length) {
                let ok = false;
                for (const a of allowedSums) {
                  if (sum === a) { ok = true; break; }
                }
                if (!ok) return;

                anySolution = true;
                for (let k = 0; k < targets.length; k++) {
                  localPossible[k].add(cur[k]);
                }
                return;
              }
              const domArr = doms[idx];
              for (const v of domArr) {
                cur[idx] = v;
                dfs(idx + 1, sum + v);
              }
            }

            dfs(0, 0);
            if (!anySolution) continue;

            // å„ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã® domain ã¨ localPossible ã® intersection ã‚’å–ã‚‹
            for (let i = 0; i < targets.length; i++) {
              const t = targets[i];
              const newSet = localPossible[i];
              if (newSet.size === 0) continue;
              if (intersectDomain(t.domain, newSet)) {
                changed = true;
              }
            }
          }
        }

        if (!changed) break; // åæŸ
      }

      // 3. domain ã«åŸºã¥ã„ã¦å®‰å…¨ï¼åœ°é›·ï¼‹æ——ã‚’ä»˜ã‘ã‚‹
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.open) continue;

          const s = cell.domain;
          if (!s || s.size === 0) continue;

          const has0 = s.has(0);
          const has1 = s.has(1);
          const has2 = s.has(2);

          // å¸¸ã«0 â†’ å®‰å…¨ç¢ºå®š
          if (!has1 && !has2) {
            markSafe(cell);
            // å®‰å…¨ç¢ºå®šãªã®ã§æ——ã¯æ¶ˆã—ã¦ãŠã
            cell.flag = false;
            cell.flagType = null;
            cell.el.classList.remove('flag');
          }

          // 0 ãŒã‚ã‚Šå¾—ãªã„ï¼ˆ1 or 2 ã®ã¿ï¼‰ â†’ åœ°é›·ç¢ºå®š
          if (!has0 && (has1 || has2)) {
            let type = "unknown";
            if (has1 && !has2) type = "normal";
            else if (!has1 && has2) type = "heavy";
            markMine(cell, type);
          }
        }
      }
    }

    function markSafe(cell) {
      if (cell.hintStatus === "mine") return;
      cell.hintStatus = "safe";
      cell.el.classList.add('hint-safe');
    }

    function markMine(cell, mineType) {
      cell.hintStatus = "mine";
      cell.el.classList.add('hint-mine');

      // è‡ªå‹•ãƒ•ãƒ©ã‚°ä»˜ä¸ï¼ˆã‚ã‹ã‚‰ãªã„ï¼1ï¼2ï¼‰
      cell.flag = true;
      cell.flagType = mineType;
      cell.el.classList.add('flag');

      if (mineType === "normal") {
        cell.el.textContent = '1';
      } else if (mineType === "heavy") {
        cell.el.textContent = '2';
      } else {
        cell.el.textContent = 'ğŸš©?';
      }
    }

    // åˆæœŸåŒ–
    init();
  </script>
</body>
</html>
