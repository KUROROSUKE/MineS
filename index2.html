<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #f0f0f0;
      padding: 10px;
      user-select: none;
    }
    h1 {
      font-size: 24px;
      margin: 10px 0;
    }
    h2 {
      font-size: 14px;
      margin: 5px 0 15px;
      text-align: center;
      line-height: 1.6;
    }
    #controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    button {
      padding: 12px 24px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #2196f3;
      color: white;
    }
    button.flag-mode {
      background: #ff9800;
    }
    #status {
      font-size: 18px;
      font-weight: bold;
      margin-top: 10px;
    }
    #board {
      display: grid;
      gap: 2px;
      box-sizing: border-box;
      margin: 0 auto;
      transition: all 0.2s ease-in-out;
    }
    .cell {
      background: #bbb;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      color: #333;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s;
      aspect-ratio: 1 / 1;
      user-select: none;
    }
    .cell.open {
      background: #e0e0e0;
    }
    .cell.flag {
      background: #ffeb3b;
      color: #d32f2f;
    }
    .cell.mine {
      background: #f44336;
      color: white;
    }
    .timer {
      font-size: 20px;
      font-weight: bold;
      margin-top: 10px;
    }

    /* ãƒ’ãƒ³ãƒˆç”¨ï¼šå…ƒã®è‰²ã‚’å¤‰ãˆãšå¤–æ ã ã‘è¡¨ç¤º */
    .cell.hint-safe {
      outline: 2px solid #00c853; /* ç·‘ */
      outline-offset: -2px;
    }
    .cell.hint-mine {
      outline: 2px solid #d50000; /* èµ¤ */
      outline-offset: -2px;
    }

    @media (max-width: 600px) {
      button {
        font-size: 16px;
        padding: 10px 20px;
      }
      h1 {
        font-size: 20px;
      }
      #status, .timer {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <h1>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</h1>
  <h2>
    1ãƒã‚¹ã§çˆ†å¼¾2å€‹åˆ†ã‚«ã‚¦ãƒ³ãƒˆã®é‡çˆ†å¼¾ãŒç´›ã‚Œè¾¼ã‚“ã§ã„ã‚‹ã€‚<br>
    ã¾ãŸã€æœ¬æ¥ã‚ˆã‚Š1å°‘ãªãè¡¨ç¤ºã•ã‚Œã‚‹å ´åˆãŒã‚ã‚‹ã€‚ï¼ˆæœ€å°å€¤1ï¼‰
  </h2>
  <div id="controls">
    <button id="flagButton">ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ OFF</button>
    <button id="resetButton">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
  </div>
  <div id="status"></div>
  <div id="board"></div>
  <div id="timer" class="timer">æ™‚é–“: 0</div>

  <script>
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const flagButton = document.getElementById('flagButton');
    const resetButton = document.getElementById('resetButton');
    const timerEl = document.getElementById('timer');

    const size = 20;
    const mineCount = 100;
    const DECEPTION_PROBABILITY = 0.5; // 50%ã§è¡¨ç¤ºæ•°å€¤ã‚’-1ï¼ˆãŸã ã—æœ€å°1ï¼‰

    let gameOver = false;
    let flagMode = false;
    let openedCount = 0;
    let board = [];
    let timer = null;
    let timerSeconds = 0;
    let firstClick = null; // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ä½ç½®ï¼ˆãã®å‘¨å›²ã¯å®‰å…¨ï¼‰

    flagButton.addEventListener('click', () => {
      flagMode = !flagMode;
      flagButton.textContent = flagMode ? 'ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ ON' : 'ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ OFF';
      flagButton.classList.toggle('flag-mode', flagMode);
    });

    resetButton.addEventListener('click', init);

    function init() {
      board = [];
      gameOver = false;
      openedCount = 0;
      firstClick = null;
      statusEl.textContent = '';
      boardEl.innerHTML = '';
      timerSeconds = 0;
      timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
      clearInterval(timer);
      timer = setInterval(() => {
        if (!gameOver) {
          timerSeconds++;
          timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
        }
      }, 1000);

      const shortSide = Math.min(window.innerWidth, window.innerHeight) * 0.9;
      boardEl.style.width = `${shortSide}px`;
      boardEl.style.height = `${shortSide}px`;
      boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      boardEl.style.gridTemplateRows = `repeat(${size}, 1fr)`;

      for (let y = 0; y < size; y++) {
        board[y] = [];
        for (let x = 0; x < size; x++) {
          const cellEl = document.createElement('div');
          cellEl.className = 'cell';
          cellEl.dataset.x = x;
          cellEl.dataset.y = y;
          boardEl.appendChild(cellEl);

          const cell = {
            x,
            y,
            mine: null,           // null / "normal" / "heavy"ï¼ˆå†…éƒ¨ç”¨ãƒ»ãƒ’ãƒ³ãƒˆã§ã¯ä½¿ã‚ãªã„ï¼‰
            open: false,
            flag: false,          // ä½•ã‹ã—ã‚‰ã®æ——ãŒç«‹ã£ã¦ã„ã‚‹ã‹
            flagType: null,       // null / "unknown" / "normal" / "heavy"
            count: 0,             // çœŸã®ã‚«ã‚¦ãƒ³ãƒˆï¼ˆå†…éƒ¨ç”¨ãƒ»ãƒ’ãƒ³ãƒˆã§ã¯ä½¿ã‚ãªã„ï¼‰
            displayCount: null,   // ç”»é¢ã«è¦‹ãˆã¦ã„ã‚‹æ•°å­—ï¼ˆæ¬ºçè¾¼ã¿ï¼‰â€»ãƒ’ãƒ³ãƒˆã¯ã“ã‚Œã®ã¿ä½¿ç”¨
            hintStatus: null,     // null / "safe" / "mine"
            mineTypeHint: null,   // null / "normal" / "heavy" / "unknown"
            el: cellEl
          };
          board[y][x] = cell;

          cellEl.addEventListener('click', () => handleCellClick(cell));
        }
      }

      clearHints();
    }

    function handleCellClick(cell) {
      if (gameOver || cell.open) return;

      // æ——ãƒ¢ãƒ¼ãƒ‰ï¼šçŠ¶æ…‹ã‚’å¾ªç’°
      if (flagMode) {
        if (!cell.open) {
          cycleFlag(cell);
          updateHints(); // æ——ã®æƒ…å ±è¾¼ã¿ã§å†æ¨è«–ï¼ˆè¡¨ç¤ºæƒ…å ±ã ã‘ï¼‰
        }
        return;
      }

      // æ——ãŒã‚ã‚‹ãƒã‚¹ã¯é–‹ã‹ãªã„
      if (cell.flag) return;

      // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ã§åœ°é›·é…ç½®ï¼ˆãã®ãƒã‚¹ã¨å‘¨å›²3x3ã‚’å®‰å…¨ã«ï¼‰
      if (!firstClick) {
        firstClick = { x: cell.x, y: cell.y };
        placeMines();
      }

      openCell(cell);

      if (cell.mine) {
        cell.el.classList.add('mine');
        cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
        endGame(false);
        return;
      }

      if (cell.count === 0) {
        openSurrounding(cell.x, cell.y);
      }

      updateHints();

      if (openedCount === size * size - mineCount) {
        endGame(true);
      }
    }

    // æ——çŠ¶æ…‹ã®å¾ªç’°ï¼šãªã— â†’ ä¸æ˜ â†’ 1 â†’ 2 â†’ ãªã—
    function cycleFlag(cell) {
      if (!cell.flag) {
        cell.flag = true;
        cell.flagType = "unknown";
        cell.el.classList.add('flag');
        cell.el.textContent = 'ğŸš©?';
      } else if (cell.flagType === "unknown") {
        cell.flagType = "normal";
        cell.el.classList.add('flag');
        cell.el.textContent = '1';
      } else if (cell.flagType === "normal") {
        cell.flagType = "heavy";
        cell.el.classList.add('flag');
        cell.el.textContent = '2';
      } else {
        cell.flag = false;
        cell.flagType = null;
        cell.el.classList.remove('flag');
        cell.el.textContent = '';
      }
    }

    function placeMines() {
      let mines = 0;
      const safeCells = new Set();

      // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã¨ãã®å‘¨å›²3x3ã¯åœ°é›·ç¦æ­¢
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = firstClick.x + dx;
          const ny = firstClick.y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            safeCells.add(`${nx},${ny}`);
          }
        }
      }

      // é‡çˆ†å¼¾(2ã‚«ã‚¦ãƒ³ãƒˆ)ã®æ•°ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ±ºå®š
      const heavyMineCount = Math.floor(Math.random() * (mineCount + 1));
      let heavyMines = 0;

      while (mines < mineCount) {
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        const cell = board[y][x];

        if (!cell.mine && !safeCells.has(`${x},${y}`)) {
          if (heavyMines < heavyMineCount) {
            cell.mine = "heavy";
            heavyMines++;
          } else {
            cell.mine = "normal";
          }
          mines++;
        }
      }

      // åœ°é›·ä»¥å¤–ã®ãƒã‚¹ã®çœŸã®ã‚«ã‚¦ãƒ³ãƒˆï¼ˆå†…éƒ¨ç”¨ï¼‰
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.mine) continue;
          cell.count = getMineCount(x, y);
        }
      }
    }

    function getMineCount(x, y) {
      let count = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
          if (dx === 0 && dy === 0) continue;
          const neighbor = board[ny][nx];
          if (neighbor.mine === "normal") count += 1;
          else if (neighbor.mine === "heavy") count += 2;
        }
      }
      return count;
    }

    function openCell(cell) {
      if (cell.open || gameOver) return;
      cell.open = true;
      openedCount++;
      cell.el.classList.add('open');

      // ä¿é™ºï¼šé–‹ã„ãŸã¨ãã«ã¯æ——ã‚’æ¶ˆã™
      if (cell.flag) {
        cell.flag = false;
        cell.flagType = null;
        cell.el.classList.remove('flag');
      }

      // è¡¨ç¤ºã•ã‚Œã‚‹æ•°å­—ã‚’æ±ºã‚ã‚‹ï¼ˆã“ã“ãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æŒã¤æƒ…å ±ï¼‰
      if (!cell.mine) {
        if (cell.count === 0) {
          // 0 ã®ã¨ãã¯ä½•ã‚‚æã‹ãªã„ãŒã€displayCount ã¯ 0 ã¨ã—ã¦ä¿æŒ
          cell.displayCount = 0;
          cell.el.textContent = '';
        } else {
          let displayCount = cell.count;
          if (Math.random() < DECEPTION_PROBABILITY) {
            displayCount = Math.max(1, cell.count - 1);
          }
          cell.displayCount = displayCount;   // â˜… ãƒ’ãƒ³ãƒˆå´ã¯ã“ã‚Œã ã‘ã‚’è¦‹ã‚‹
          cell.el.textContent = displayCount;
          cell.el.style.color = getNumberColor(displayCount);
        }
      }
    }

    function getNumberColor(num) {
      switch (num) {
        case 1: return '#1976d2';
        case 2: return '#388e3c';
        case 3: return '#d32f2f';
        case 4: return '#7b1fa2';
        case 5: return '#f57c00';
        case 6: return '#00897b';
        case 7: return '#616161';
        case 8: return '#000000';
        default: return '#000000';
      }
    }

    function openSurrounding(x, y) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
          if (dx === 0 && dy === 0) continue;
          const neighbor = board[ny][nx];
          if (!neighbor.open && !neighbor.mine) {
            openCell(neighbor);
            if (neighbor.count === 0) {
              openSurrounding(nx, ny);
            }
          }
        }
      }
    }

    function endGame(win) {
      gameOver = true;
      clearInterval(timer);
      statusEl.textContent = win ? 'ã‚¯ãƒªã‚¢ï¼' : 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼';

      // åœ°é›·ã‚’å…¨è¡¨ç¤ºï¼ˆã“ã‚Œã¯ã‚²ãƒ¼ãƒ çµ‚äº†å¾Œã ã‘ã®å†…éƒ¨æƒ…å ±é–‹ç¤ºï¼‰
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.mine && !cell.open) {
            cell.el.classList.add('mine');
            cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
          }
        }
      }
    }

    // ---------- ãƒ’ãƒ³ãƒˆé–¢é€£ï¼ˆè¡¨ç¤ºæƒ…å ±ã ã‘ã‚’ä½¿ã†ï¼‰ ----------

    function clearHints() {
      for (let y = 0; y < size; y++) {
        if (!board[y]) continue;
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (!c) continue;
          c.hintStatus = null;
          c.mineTypeHint = null;
          c.el.classList.remove('hint-safe', 'hint-mine');
        }
      }
    }

    // å„æ•°å­—ãƒã‚¹ã”ã¨ã«ã€ŒdisplayCount ã¨æ——ã®æƒ…å ±ã€ã ã‘ã‚’ä½¿ã£ã¦å…¨ãƒ‘ã‚¿ãƒ¼ãƒ³æ¢ç´¢ã€‚
    // ãƒ»å¸¸ã«0 â†’ å®‰å…¨ç¢ºå®šï¼ˆç·‘æ ï¼‰
    // ãƒ»å¸¸ã« >0 â†’ åœ°é›·ç¢ºå®šï¼ˆèµ¤æ ï¼‰
    function updateHints() {
      clearHints();
      if (!firstClick) return; // ã¾ã ä½•ã‚‚è¦‹ãˆã¦ã„ãªã„

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (!cell.open) continue;

          // displayCount ãŒ null â†’ ã¾ã æ•°å­—ãŒå‡ºã¦ã„ãªã„ï¼ˆ0 ã®å ´åˆã‚‚ã‚ã‚‹ï¼‰
          // ã‚¼ãƒ­ãƒã‚¹ã¯ N=0 ã¨ã—ã¦æ‰±ã†ï¼ˆä½•ã‚‚æã‹ã‚Œã¦ãªãã¦ã‚‚ã€Œ0ã€ã¨ã¿ãªã›ã‚‹ï¼‰
          const N = (cell.displayCount != null) ? cell.displayCount : 0;
          if (N <= 0) continue; // 0 ã¯åˆ¶ç´„ã«ãªã‚‰ãªã„ã®ã§ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ã‚‚ã‚ˆã„ãŒã€
                               // 0 ã®ã¨ãã¯åˆ¥é€”ã€Œå…¨éƒ¨å®‰å…¨ã€ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ›¸ã„ã¦ã‚‚ã‚ˆã„

          const neighbors = [];
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              const nx = x + dx;
              const ny = y + dy;
              if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
                neighbors.push(board[ny][nx]);
              }
            }
          }

          const domains = [];
          for (let i = 0; i < neighbors.length; i++) {
            const n = neighbors[i];
            let dom;
            if (n.open) {
              // é–‹ã„ã¦ã„ã‚‹ãƒã‚¹ã¯å¿…ãš 0ï¼ˆè¡¨ç¤ºä¸Šï¼šåœ°é›·ã§ã¯ãªã„ã¨åˆ†ã‹ã£ã¦ã„ã‚‹ï¼‰
              dom = [0];
            } else {
              // é–‰ã˜ã¦ã„ã‚‹ãƒã‚¹ï¼ˆæ——ã®ç¨®é¡ã§åˆ†å²ï¼‰
              if (n.flagType === "normal") {
                dom = [1];
              } else if (n.flagType === "heavy") {
                dom = [2];
              } else if (n.flagType === "unknown" && n.flag) {
                dom = [1, 2];
              } else {
                // æ——ãªã— â†’ åœ°é›·ãªã—(0) or 1 or 2
                dom = [0, 1, 2];
              }
            }
            domains.push(dom);
          }

          const possibleValues = Array(neighbors.length)
            .fill(0)
            .map(() => new Set());
          let hasSolution = false;
          const current = new Array(neighbors.length).fill(0);

          function dfs(idx, sum) {
            if (sum > N) return; // ã“ã‚Œä»¥ä¸Šå¢—ãˆã¦ã‚‚ N ã‚’è¶…ãˆã‚‹ã®ã§æ‰“ã¡åˆ‡ã‚Š

            if (idx === neighbors.length) {
              if (sum === N) {
                hasSolution = true;
                for (let k = 0; k < neighbors.length; k++) {
                  possibleValues[k].add(current[k]);
                }
              }
              return;
            }

            for (const v of domains[idx]) {
              current[idx] = v;
              dfs(idx + 1, sum + v);
            }
          }

          dfs(0, 0);

          if (!hasSolution) {
            // ã“ã®æ•°å­—ï¼‹æ——ã®çµ„ã¿åˆã‚ã›è‡ªä½“ãŒçŸ›ç›¾ â†’ ãƒ’ãƒ³ãƒˆã¯ä½•ã‚‚å‡ºã•ãªã„
            continue;
          }

          // å„éš£æ¥ãƒã‚¹ã”ã¨ã«å®‰å…¨ç¢ºå®š or åœ°é›·ç¢ºå®šã‚’åˆ¤å®š
          for (let i = 0; i < neighbors.length; i++) {
            const n = neighbors[i];
            if (n.open) continue; // æ—¢ã«é–‹ã„ã¦ã„ã‚‹ãƒã‚¹ã¯å¯¾è±¡å¤–

            const vals = possibleValues[i];
            if (vals.size === 0) continue;

            const has0 = vals.has(0);
            const has1 = vals.has(1);
            const has2 = vals.has(2);

            // å¸¸ã«0 â†’ å®‰å…¨ç¢ºå®š
            if (!has1 && !has2) {
              markSafe(n);
            }

            // å¸¸ã« >0 â†’ åœ°é›·ç¢ºå®š
            if (!has0) {
              let mineType = null;
              if (has1 && !has2) mineType = "normal";
              else if (!has1 && has2) mineType = "heavy";
              else mineType = "unknown"; // 1ã‚‚2ã‚‚ã‚ã‚Šå¾—ã‚‹

              markMine(n, mineType);
            }
          }
        }
      }
    }

    function markSafe(cell) {
      // æ—¢ã«ã€Œåœ°é›·ç¢ºå®šã€ãŒä»˜ã„ã¦ã„ãŸã‚‰ä¸Šæ›¸ãã—ãªã„
      if (cell.hintStatus === "mine") return;
      cell.hintStatus = "safe";
      cell.el.classList.add('hint-safe');
    }

    function markMine(cell, mineType) {
      cell.hintStatus = "mine";
      cell.mineTypeHint = mineType;
      cell.el.classList.add('hint-mine');

      // ãƒ•ãƒ©ã‚°ãŒã‚ã‚‹ãŒç¨®åˆ¥ä¸æ˜ãªã‚‰è£œå®Œã™ã‚‹ï¼ˆè¡¨ç¤ºã¯ç›¤é¢æƒ…å ±ã®ç¯„å›²å†…ï¼‰
      if (cell.flag && (!cell.flagType || cell.flagType === "unknown")) {
        if (mineType === "normal") {
          cell.flagType = "normal";
          cell.el.textContent = '1';
        } else if (mineType === "heavy") {
          cell.flagType = "heavy";
          cell.el.textContent = '2';
        } else {
          cell.flagType = "unknown";
          cell.el.textContent = 'ğŸš©?';
        }
        cell.el.classList.add('flag');
      }
    }

    // åˆæœŸåŒ–
    init();
  </script>
</body>
</html>
