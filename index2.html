<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #f0f0f0;
      padding: 10px;
      user-select: none;
    }
    h1 {
      font-size: 24px;
      margin: 10px 0;
    }
    #controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    button {
      padding: 12px 24px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #2196f3;
      color: white;
    }
    button.flag-mode {
      background: #ff9800;
    }
    #status {
      font-size: 18px;
      font-weight: bold;
      margin-top: 10px;
      text-align: center;
      white-space: pre-line;
    }
    #board {
      display: grid;
      gap: 2px;
      box-sizing: border-box;
      margin: 0 auto;
      transition: all 0.2s ease-in-out;
    }
    .cell {
      background: #bbb;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      color: #333;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s, box-shadow 0.2s;
      aspect-ratio: 1 / 1;
      user-select: none;
    }
    .cell.open {
      background: #e0e0e0;
    }
    .cell.flag {
      background: #ffeb3b;
      color: #d32f2f;
    }
    .cell.mine {
      background: #f44336;
      color: white;
    }
    .timer {
      font-size: 20px;
      font-weight: bold;
      margin-top: 10px;
    }

    /* â–¼ ãƒ’ãƒ³ãƒˆè¡¨ç¤ºç”¨ã®è£…é£¾ â–¼ */
    .cell.logic-safe {
      box-shadow: 0 0 0 3px #4caf50 inset; /* ç·‘æ ï¼šå®‰å…¨ç¢ºå®š */
    }
    .cell.logic-mine {
      box-shadow: 0 0 0 3px #f44336 inset; /* èµ¤æ ï¼šåœ°é›·ç¢ºå®š */
    }
    .cell.logic-prob {
      box-shadow: 0 0 0 2px #9e9e9e inset; /* ã‚°ãƒ¬ãƒ¼æ ï¼šç¢ºç‡è¡¨ç¤º */
      font-size: 11px;
    }

    @media (max-width: 600px) {
      button {
        font-size: 16px;
        padding: 10px 20px;
      }
      h1 {
        font-size: 20px;
      }
      #status, .timer {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <h1>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</h1>
  <h2>1ãƒã‚¹ã§çˆ†å¼¾2å€‹åˆ†ã‚«ã‚¦ãƒ³ãƒˆã®é‡çˆ†å¼¾ãŒç´›ã‚Œè¾¼ã‚“ã§ã„ã‚‹ã€‚<br>ã¾ãŸã€æœ¬æ¥ã‚ˆã‚Š1å°‘ãªãè¡¨ç¤ºã•ã‚Œã‚‹å ´åˆãŒã‚ã‚‹ã€‚ï¼ˆæœ€å°å€¤1ï¼‰</h2>

  <div id="controls">
    <button id="flagButton">ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ OFF</button>
    <button id="resetButton">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
  </div>
  <div id="status"></div>
  <div id="board"></div>
  <div id="timer" class="timer">æ™‚é–“: 0</div>

  <!-- ã‚²ãƒ¼ãƒ æœ¬ä½“ -->
  <script>
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const flagButton = document.getElementById('flagButton');
    const resetButton = document.getElementById('resetButton');
    const timerEl = document.getElementById('timer');

    const size = 20;
    const mineCount = 100;
    const DECEPTION_PROBABILITY = 0.5; // 50%ã§è¡¨ç¤ºæ•°å€¤ã‚’-1ï¼ˆãŸã ã—æœ€å°1ï¼‰
    let gameOver = false;
    let flagMode = false;
    let openedCount = 0;
    let board = [];
    let timer;
    let timerSeconds = 0;
    let firstClick = null;

    flagButton.addEventListener('click', () => {
      flagMode = !flagMode;
      flagButton.textContent = flagMode ? 'ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ ON' : 'ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ OFF';
      flagButton.classList.toggle('flag-mode', flagMode);
    });

    resetButton.addEventListener('click', init);

    function requestHint() {
      if (typeof showHint === 'function' && !gameOver) {
        showHint();
      }
    }

    function init() {
      board = [];
      gameOver = false;
      openedCount = 0;
      firstClick = null;
      statusEl.textContent = '';
      boardEl.innerHTML = '';
      timerSeconds = 0;
      timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
      clearInterval(timer);
      timer = setInterval(() => {
        if (!gameOver) {
          timerSeconds++;
          timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
        }
      }, 1000);

      const shortSide = Math.min(window.innerWidth, window.innerHeight) * 0.9;
      boardEl.style.width = `${shortSide}px`;
      boardEl.style.height = `${shortSide}px`;
      boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      boardEl.style.gridTemplateRows = `repeat(${size}, 1fr)`;

      for (let y = 0; y < size; y++) {
        board[y] = [];
        for (let x = 0; x < size; x++) {
          const cellEl = document.createElement('div');
          cellEl.className = 'cell';
          cellEl.dataset.x = x;
          cellEl.dataset.y = y;
          boardEl.appendChild(cellEl);

          const cell = {
            x,
            y,
            mine: null, // null / "normal" / "heavy"
            open: false,
            flag: false,
            count: 0,
            el: cellEl
          };
          board[y][x] = cell;

          cellEl.addEventListener('click', () => handleCellClick(cell));
        }
      }

      if (typeof clearHints === 'function') clearHints();
    }

    function handleCellClick(cell) {
      if (gameOver) return;

      // æ——ãƒ¢ãƒ¼ãƒ‰æ™‚
      if (flagMode) {
        if (!cell.open) {
          if (typeof clearHints === 'function') clearHints();
          cell.flag = !cell.flag;
          cell.el.classList.toggle('flag', cell.flag);
          cell.el.textContent = cell.flag ? 'ğŸš©' : '';
          requestHint();
        }
        return;
      }

      // é€šå¸¸ã‚¯ãƒªãƒƒã‚¯
      if (cell.open || cell.flag) return;
      if (typeof clearHints === 'function') clearHints();

      // åˆã‚¯ãƒªãƒƒã‚¯ã§åœ°é›·é…ç½®
      if (!firstClick) {
        firstClick = { x: cell.x, y: cell.y };
        placeMines();
      }

      openCell(cell);

      if (cell.mine) {
        cell.el.classList.add('mine');
        cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
        endGame(false);
        return;
      }

      if (cell.count === 0) {
        openSurrounding(cell.x, cell.y);
      }

      if (openedCount === size * size - mineCount) {
        endGame(true);
        return;
      }

      requestHint();
    }

    function placeMines() {
      let mines = 0;
      const safeCells = new Set();

      // åˆæ‰‹ã¨ãã®å‘¨å›²ã¯å®‰å…¨
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = firstClick.x + dx;
          const ny = firstClick.y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            safeCells.add(`${nx},${ny}`);
          }
        }
      }

      const heavyMineCount = Math.floor(Math.random() * (mineCount + 1));
      let heavyMines = 0;

      while (mines < mineCount) {
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        const cell = board[y][x];
        if (!cell.mine && !safeCells.has(`${x},${y}`)) {
          if (heavyMines < heavyMineCount) {
            cell.mine = "heavy";
            heavyMines++;
          } else {
            cell.mine = "normal";
          }
          mines++;
        }
      }

      // æœ¬å½“ã®åˆè¨ˆã‚«ã‚¦ãƒ³ãƒˆï¼ˆé‡çˆ†å¼¾ã¯2ã‚«ã‚¦ãƒ³ãƒˆï¼‰
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (board[y][x].mine) continue;
          board[y][x].count = getMineCount(x, y);
        }
      }
    }

    function getMineCount(x, y) {
      let count = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            const mineType = board[ny][nx].mine;
            if (mineType === "normal") count += 1;
            else if (mineType === "heavy") count += 2;
          }
        }
      }
      return count;
    }

    function openCell(cell) {
      if (cell.open) return;
      cell.open = true;
      openedCount++;
      cell.el.classList.add('open');

      if (cell.count > 0) {
        let displayCount = cell.count;
        if (Math.random() < DECEPTION_PROBABILITY) {
          displayCount = Math.max(1, cell.count - 1);
        }
        cell.el.textContent = displayCount;
        cell.el.style.color = getNumberColor(displayCount);
      }

      if (openedCount === size * size - mineCount) {
        endGame(true);
      }
    }

    function getNumberColor(num) {
      switch (num) {
        case 1: return '#1976d2';
        case 2: return '#388e3c';
        case 3: return '#d32f2f';
        case 4: return '#512da8';
        case 5: return '#ffa000';
        case 6: return '#00796b';
        case 7: return '#000000';
        case 8: return '#7b1fa2';
        default: return '#000000';
      }
    }

    function openSurrounding(x, y) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            const neighbor = board[ny][nx];
            if (!neighbor.open && !neighbor.mine && !neighbor.flag) {
              openCell(neighbor);
              if (neighbor.count === 0) {
                openSurrounding(nx, ny);
              }
            }
          }
        }
      }
    }

    function endGame(win) {
      gameOver = true;
      clearInterval(timer);
      if (win) {
        statusEl.textContent = `ğŸ‰ å‹åˆ©ï¼ æ™‚é–“: ${timerSeconds}ç§’`;
      } else {
        statusEl.textContent = `ğŸ’¥ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼`;
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const cell = board[y][x];
            if (cell.mine && !cell.open) {
              cell.el.classList.add('mine');
              cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
            }
          }
        }
      }
    }

    init();
  </script>

  <!-- ãƒ’ãƒ³ãƒˆã‚½ãƒ«ãƒãƒ¼ï¼šå„ãƒã‚¹ã”ã¨ã«ãƒ­ãƒ¼ã‚«ãƒ«åˆ¶ç´„ã‚’å…¨æ¢ç´¢ -->
  <script>
  (function() {
    const STATE = { SAFE: 0, MINE_NORMAL: 1, MINE_HEAVY: 2 };
    const MAX_LOCAL_VARS = 13; // 1ãƒã‚¹ã‚ãŸã‚Šã®ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°æ•°ã®ä¸Šé™ï¼ˆ3^13 ã¾ã§ï¼‰

    // ãƒ’ãƒ³ãƒˆã®ã‚¯ãƒªã‚¢
    window.clearHints = function() {
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          c.el.classList.remove('logic-safe', 'logic-mine', 'logic-prob');
          c.el.title = '';
          if (!c.open && !c.flag) {
            c.el.textContent = '';
          }
        }
      }
    };

    // æ•°å­—ãƒã‚¹ã¨ãã®å‘¨å›²ã®åˆ¶ç´„ã‚’é›†ã‚ã‚‹
    function getConstraints() {
      const list = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (!c.open) continue;
          if (c.el.textContent === '') continue;

          const d = parseInt(c.el.textContent);
          if (isNaN(d) || d <= 0) continue;

          const neighbors = [];
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              const nx = x + dx, ny = y + dy;
              if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
              neighbors.push(board[ny][nx]);
            }
          }

          list.push({
            x,
            y,
            display: d,
            neighbors
          });
        }
      }
      return list;
    }

    // éƒ¨åˆ†å‰²ã‚Šå½“ã¦ assignment ãŒåˆ¶ç´„ã‚’ã¾ã æº€ãŸã—å¾—ã‚‹ã‹ï¼ˆS âˆˆ {d, d+1}ï¼‰
    function isValidLocal(constraints, assignment, variableKeySet) {
      for (let c of constraints) {
        let currentSum = 0;
        let unknownCount = 0;
        let flagMin = 0;
        let flagMax = 0;

        for (let n of c.neighbors) {
          if (n.open) continue;

          if (n.flag) {
            // æ——ã¯å¿…ãš 1ã€œ2 ã®åœ°é›·
            flagMin += 1;
            flagMax += 2;
            continue;
          }

          const key = `${n.x}_${n.y}`;
          if (variableKeySet.has(key)) {
            if (assignment.has(key)) {
              currentSum += assignment.get(key); // 0 / 1 / 2
            } else {
              unknownCount++;
            }
          } else {
            // ãƒ­ãƒ¼ã‚«ãƒ«å•é¡Œã«å«ã‚ã¦ã„ãªã„æœªé–‹ã‚»ãƒ« â†’ 0ã€œ2 ã©ã‚Œã§ã‚‚å–ã‚Šå¾—ã‚‹
            unknownCount++;
          }
        }

        const d = c.display;
        const minTotal = currentSum + flagMin;
        const maxTotal = currentSum + flagMax + unknownCount * 2;

        // çœŸã®åˆè¨ˆ S ã¯ display ã¾ãŸã¯ display+1
        if (maxTotal < d) return false;
        if (minTotal > d + 1) return false;
      }
      return true;
    }

    // 1ãƒã‚¹ï¼ˆtargetCellï¼‰ã«ã¤ã„ã¦ã€ãã®ãƒã‚¹ã«é–¢ã‚ã‚‹ãƒ­ãƒ¼ã‚«ãƒ«åˆ¶ç´„ã ã‘ã§ç¢ºç‡ã‚’è¨ˆç®—
    function computeLocalProbForCell(targetCell, constraints, cellToConstraints) {
      const keyTarget = `${targetCell.x}_${targetCell.y}`;

      // ãã‚‚ãã‚‚ã©ã®åˆ¶ç´„ã«ã‚‚å‡ºã¦ã“ãªã„ï¼ˆæ•°å­—ã«éš£æ¥ã—ã¦ã„ãªã„ï¼‰ãªã‚‰ä½•ã‚‚åˆ†ã‹ã‚‰ãªã„
      const initialConsIdxs = cellToConstraints.get(keyTarget);
      if (!initialConsIdxs || initialConsIdxs.length === 0) {
        return null;
      }

      const variableCells = new Set();      // Cell ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é›†åˆ
      const variableList = [];              // é †åºä»˜ããƒªã‚¹ãƒˆ
      const variableKeySet = new Set();     // "x_y" ã®é›†åˆ
      const constraintIndexSet = new Set(); // ä½¿ã†åˆ¶ç´„ã® index é›†åˆ
      const queue = [];

      function addVariableCell(c) {
        const k = `${c.x}_${c.y}`;
        if (!variableKeySet.has(k) && !c.open && !c.flag) {
          variableKeySet.add(k);
          variableCells.add(c);
          variableList.push(c);
          queue.push(c);
        }
      }

      addVariableCell(targetCell);

      // BFSã§ã€Œtarget ã«é–¢ã‚ã‚‹åˆ¶ç´„ã€ã¨ã€Œãã®åˆ¶ç´„ã«å‡ºã¦ãã‚‹è¿‘å‚ã®æœªé–‹ã‚»ãƒ«ã€ã‚’é›†ã‚ã‚‹
      while (queue.length > 0 && variableList.length < MAX_LOCAL_VARS) {
        const cur = queue.shift();
        const kCur = `${cur.x}_${cur.y}`;
        const consIdxs = cellToConstraints.get(kCur) || [];
        for (let idx of consIdxs) {
          if (!constraintIndexSet.has(idx)) {
            constraintIndexSet.add(idx);
          }
          const cons = constraints[idx];
          for (let n of cons.neighbors) {
            if (variableList.length >= MAX_LOCAL_VARS) break;
            if (!n.open && !n.flag) {
              addVariableCell(n);
            }
          }
          if (variableList.length >= MAX_LOCAL_VARS) break;
        }
      }

      const localConstraints = Array.from(constraintIndexSet).map(i => constraints[i]);
      if (localConstraints.length === 0) return null;

      const assignment = new Map();
      let total = 0;
      let safeCount = 0;

      function backtrack(idx) {
        if (idx === variableList.length) {
          // å…¨å¤‰æ•°ã«å€¤ã‚’å…¥ã‚ŒãŸçŠ¶æ…‹ã§åˆ¶ç´„ã‚’æº€ãŸã™ã‹ç¢ºèª
          if (isValidLocal(localConstraints, assignment, variableKeySet)) {
            total++;
            if (assignment.get(keyTarget) === STATE.SAFE) {
              safeCount++;
            }
          }
          return;
        }

        const v = variableList[idx];
        const k = `${v.x}_${v.y}`;

        for (let state of [STATE.SAFE, STATE.MINE_NORMAL, STATE.MINE_HEAVY]) {
          assignment.set(k, state);
          // éƒ¨åˆ†å‰²ã‚Šå½“ã¦ã®æ™‚ç‚¹ã§çŸ›ç›¾ã—ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæ—©æœŸ pruningï¼‰
          if (isValidLocal(localConstraints, assignment, variableKeySet)) {
            backtrack(idx + 1);
          }
          assignment.delete(k);
        }
      }

      backtrack(0);

      if (total === 0) return null;  // å±€æ‰€åˆ¶ç´„ã ã‘ã§ã¯ä¸€åˆ‡æ•´åˆã—ãªã„ â†’ ã“ã“ã§ã¯è«¦ã‚ã¦æƒ…å ±ãªã—æ‰±ã„

      const safeProb = safeCount / total;
      return { safeProb, mineProb: 1 - safeProb };
    }

    // ãƒ¡ã‚¤ãƒ³ï¼šè‡ªå‹•ãƒ’ãƒ³ãƒˆè¡¨ç¤º
    window.showHint = function() {
      if (gameOver) return;

      clearHints();

      const constraints = getConstraints();

      // ã‚»ãƒ« â†’ ãã®ã‚»ãƒ«ãŒå«ã¾ã‚Œã‚‹åˆ¶ç´„ index ã®å¯¾å¿œã‚’ä½œã‚‹
      const cellToConstraints = new Map();
      constraints.forEach((cons, idx) => {
        cons.neighbors.forEach(n => {
          const k = `${n.x}_${n.y}`;
          if (!cellToConstraints.has(k)) {
            cellToConstraints.set(k, []);
          }
          cellToConstraints.get(k).push(idx);
        });
      });

      let safe100 = 0;
      let mine100 = 0;

      // å„ãƒã‚¹ã®ç¢ºç‡ã‚’è¨ˆç®—
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.open || cell.flag) continue;

          const k = `${x}_${y}`;
          const prob = computeLocalProbForCell(cell, constraints, cellToConstraints);

          let safeProb, mineProb;
          let fromLogic = false;

          if (prob) {
            safeProb = prob.safeProb;
            mineProb = prob.mineProb;
            fromLogic = true;
          } else {
            // ã©ã®æ•°å­—ã«ã‚‚é–¢ä¿‚ã—ãªã„ or å±€æ‰€åˆ¶ç´„ã ã‘ã§ã¯ä½•ã‚‚æ±ºã¾ã‚‰ãªã„
            safeProb = 0.5;
            mineProb = 0.5;
            fromLogic = false;
          }

          const safeP = safeProb;
          const mineP = mineProb;
          const keyText =
            `å®‰å…¨: ${(safeP * 100).toFixed(1)}% / åœ°é›·: ${(mineP * 100).toFixed(1)}%`;

          if (safeP >= 0.999) {
            cell.el.classList.add('logic-safe');
            cell.el.title = 'å®‰å…¨ç¢ºå®š\n' + keyText;
            safe100++;
          } else if (mineP >= 0.999) {
            cell.el.classList.add('logic-mine');
            cell.el.title = 'åœ°é›·ç¢ºå®š\n' + keyText;
            mine100++;
          } else {
            cell.el.classList.add('logic-prob');
            cell.el.textContent = `${Math.round(safeP * 100)}%`;
            cell.el.title = (fromLogic ? '' : 'å±€æ‰€æƒ…å ±ãªã—ãƒ»æš«å®šå€¤\n') + keyText;
          }
        }
      }

      if (safe100 === 0 && mine100 === 0) {
        statusEl.textContent =
          'è«–ç†çš„ã«ç¢ºå®šã§ãã‚‹ãƒã‚¹ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚\n' +
          'æ•°å­—ã«é–¢ä¿‚ã™ã‚‹ãƒã‚¹ã¯ãƒ­ãƒ¼ã‚«ãƒ«åˆ¶ç´„ã‹ã‚‰ã®å®‰å…¨ç¢ºç‡ã‚’ã€\n' +
          'ãã‚Œä»¥å¤–ã®ãƒã‚¹ã¯æš«å®š 50% ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚';
      } else {
        statusEl.textContent =
          `è«–ç†çš„ã«å®‰å…¨ç¢ºå®š: ${safe100} ãƒã‚¹\n` +
          `è«–ç†çš„ã«åœ°é›·ç¢ºå®š: ${mine100} ãƒã‚¹\n` +
          'ãã®ä»–ã®ãƒã‚¹ã«ã¯ãƒ­ãƒ¼ã‚«ãƒ«åˆ¶ç´„ã‹ã‚‰ã®å®‰å…¨ç¢ºç‡ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚';
      }
    };
  })();
  </script>
</body>
</html>
