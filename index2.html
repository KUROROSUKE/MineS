<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ãƒ­ã‚¸ãƒƒã‚¯ä»˜ããƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #f0f0f0;
      padding: 10px;
      user-select: none;
    }
    h1 {
      font-size: 24px;
      margin: 10px 0;
    }
    #controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    button {
      padding: 12px 24px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #2196f3;
      color: white;
    }
    button.flag-mode {
      background: #ff9800;
    }
    #status {
      font-size: 18px;
      font-weight: bold;
      margin-top: 10px;
      text-align: center;
      white-space: pre-line;
    }
    #board {
      display: grid;
      gap: 2px;
      box-sizing: border-box;
      margin: 0 auto;
      transition: all 0.2s ease-in-out;
    }
    .cell {
      background: #bbb;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      color: #333;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s, box-shadow 0.2s;
      aspect-ratio: 1 / 1;
      user-select: none;
    }
    .cell.open {
      background: #e0e0e0;
    }
    .cell.flag {
      background: #ffeb3b;
      color: #d32f2f;
    }
    .cell.mine {
      background: #f44336;
      color: white;
    }
    .timer {
      font-size: 20px;
      font-weight: bold;
      margin-top: 10px;
    }

    /* ãƒ’ãƒ³ãƒˆè¡¨ç¤ºç”¨ */
    .cell.logic-safe {
      box-shadow: 0 0 0 3px #4caf50 inset; /* ç·‘æ ï¼šå®‰å…¨ç¢ºå®š or å®‰å…¨å€™è£œ */
    }
    .cell.logic-mine {
      box-shadow: 0 0 0 3px #f44336 inset; /* èµ¤æ ï¼šåœ°é›·ç¢ºå®š */
    }
  </style>
</head>
<body>
  <h1>ãƒ­ã‚¸ãƒƒã‚¯ä»˜ããƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</h1>
  <h2>
    ãƒ»ä¸€éƒ¨ã®çˆ†å¼¾ã¯ã€Œé‡çˆ†å¼¾ã€ã§ã€å‘¨å›²ã« 2 å€‹åˆ†ã¨ã—ã¦æ•°ãˆä¸Šã’ã‚‰ã‚Œã‚‹ã€‚<br>
    ãƒ»è¡¨ç¤ºã•ã‚Œã‚‹æ•°å­—ã¯ã€æœ¬æ¥ã®åˆè¨ˆã‹ã‚‰ 1 å°‘ãªã„ã“ã¨ãŒã‚ã‚‹ï¼ˆãŸã ã— 1 æœªæº€ã«ã¯ãªã‚‰ãªã„ï¼‰ã€‚<br>
    ãƒ»ãƒ’ãƒ³ãƒˆã¯ã€Œæ•°å­—ã ã‘ã€ã‚’ä½¿ã£ã¦ã€0/1/2 ã®å…¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ·±ã•åˆ¶é™ä»˜ãã§ç·å½“ãŸã‚Šã—ã¾ã™ã€‚<br>
    ãƒ»ä½•ã‚‚ç¢ºå®šã—ãªã„ã¨ãã¯ã€å®‰å…¨ãã†ãªä¸Šä½ 3 ãƒã‚¹ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
  </h2>

  <div id="controls">
    <button id="flagButton">ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ OFF</button>
    <button id="resetButton">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
  </div>
  <div id="status"></div>
  <div id="board"></div>
  <div id="timer" class="timer">æ™‚é–“: 0</div>

  <!-- ã‚²ãƒ¼ãƒ æœ¬ä½“ -->
  <script>
    const boardEl   = document.getElementById('board');
    const statusEl  = document.getElementById('status');
    const flagButton  = document.getElementById('flagButton');
    const resetButton = document.getElementById('resetButton');
    const timerEl   = document.getElementById('timer');

    const size = 20;
    const mineCount = 100;          // çˆ†å¼¾ã®å€‹æ•°ï¼ˆé‡çˆ†ã‚‚ 1 å€‹ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆï¼‰
    const DECEPTION_PROBABILITY = 0.5; // 50%ã§è¡¨ç¤ºæ•°å€¤ã‚’-1ï¼ˆãŸã ã—æœ€å°1ï¼‰

    let gameOver    = false;
    let flagMode    = false;
    let openedCount = 0;
    let board       = [];
    let timer;
    let timerSeconds = 0;
    let firstClick  = null;

    flagButton.addEventListener('click', () => {
      flagMode = !flagMode;
      flagButton.textContent = flagMode ? 'ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ ON' : 'ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ OFF';
      flagButton.classList.toggle('flag-mode', flagMode);
    });

    resetButton.addEventListener('click', init);

    function requestHint() {
      if (typeof showHint === 'function' && !gameOver) {
        showHint();
      }
    }

    function init() {
      board = [];
      gameOver = false;
      openedCount = 0;
      firstClick = null;
      statusEl.textContent = '';
      boardEl.innerHTML = '';
      timerSeconds = 0;
      timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
      clearInterval(timer);
      timer = setInterval(() => {
        if (!gameOver) {
          timerSeconds++;
          timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
        }
      }, 1000);

      const shortSide = Math.min(window.innerWidth, window.innerHeight) * 0.9;
      boardEl.style.width  = `${shortSide}px`;
      boardEl.style.height = `${shortSide}px`;
      boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      boardEl.style.gridTemplateRows    = `repeat(${size}, 1fr)`;

      for (let y = 0; y < size; y++) {
        board[y] = [];
        for (let x = 0; x < size; x++) {
          const cellEl = document.createElement('div');
          cellEl.className = 'cell';
          cellEl.dataset.x = x;
          cellEl.dataset.y = y;
          boardEl.appendChild(cellEl);

          const cell = {
            x,
            y,
            mine: null,   // null / "normal" / "heavy"ï¼ˆå†…éƒ¨ã ã‘ã§ä½¿ç”¨ï¼‰
            open: false,
            flag: false,
            count: 0,     // çœŸã®åˆè¨ˆï¼ˆé‡çˆ†ã¯2ã‚«ã‚¦ãƒ³ãƒˆï¼‰
            el: cellEl
          };
          board[y][x] = cell;

          cellEl.addEventListener('click', () => handleCellClick(cell));
        }
      }

      if (typeof clearHints === 'function') clearHints();
    }

    function handleCellClick(cell) {
      if (gameOver) return;

      // æ——ãƒ¢ãƒ¼ãƒ‰ï¼šON ã®ã¨ãã¯æ——ã® ON/OFF ã ã‘
      if (flagMode) {
        if (!cell.open) {
          if (typeof clearHints === 'function') clearHints();
          cell.flag = !cell.flag;
          cell.el.classList.toggle('flag', cell.flag);
          cell.el.textContent = cell.flag ? 'ğŸš©' : '';
          requestHint();
        }
        return;
      }

      // é€šå¸¸ã‚¯ãƒªãƒƒã‚¯
      if (cell.open || cell.flag) return;
      if (typeof clearHints === 'function') clearHints();

      // åˆã‚¯ãƒªãƒƒã‚¯ã§åœ°é›·é…ç½®
      if (!firstClick) {
        firstClick = { x: cell.x, y: cell.y };
        placeMines();
      }

      openCell(cell);

      if (cell.mine) {
        cell.el.classList.add('mine');
        cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
        endGame(false);
        return;
      }

      if (cell.count === 0) {
        openSurrounding(cell.x, cell.y);
      }

      if (openedCount === size * size - mineCount) {
        endGame(true);
        return;
      }

      requestHint();
    }

    function placeMines() {
      let mines = 0;
      const safeCells = new Set();

      // åˆæ‰‹ã¨ãã®å‘¨å›²ã¯å®‰å…¨
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = firstClick.x + dx;
          const ny = firstClick.y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            safeCells.add(`${nx},${ny}`);
          }
        }
      }

      const heavyMineCount = Math.floor(Math.random() * (mineCount + 1));
      let heavyMines = 0;

      while (mines < mineCount) {
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        const cell = board[y][x];
        if (!cell.mine && !safeCells.has(`${x},${y}`)) {
          if (heavyMines < heavyMineCount) {
            cell.mine = "heavy";
            heavyMines++;
          } else {
            cell.mine = "normal";
          }
          mines++;
        }
      }

      // çœŸã®åˆè¨ˆã‚«ã‚¦ãƒ³ãƒˆï¼ˆé‡çˆ†å¼¾ã¯2ã‚«ã‚¦ãƒ³ãƒˆï¼‰
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (board[y][x].mine) continue;
          board[y][x].count = getMineCount(x, y);
        }
      }
    }

    function getMineCount(x, y) {
      let count = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            const mineType = board[ny][nx].mine;
            if (mineType === "normal") count += 1;
            else if (mineType === "heavy") count += 2;
          }
        }
      }
      return count;
    }

    function openCell(cell) {
      if (cell.open) return;
      cell.open = true;
      openedCount++;
      cell.el.classList.add('open');

      if (cell.count > 0) {
        let displayCount = cell.count;
        if (Math.random() < DECEPTION_PROBABILITY) {
          displayCount = Math.max(1, cell.count - 1);
        }
        cell.el.textContent = displayCount;
        cell.el.style.color = getNumberColor(displayCount);
      }

      if (openedCount === size * size - mineCount) {
        endGame(true);
      }
    }

    function getNumberColor(num) {
      switch (num) {
        case 1: return '#1976d2';
        case 2: return '#388e3c';
        case 3: return '#d32f2f';
        case 4: return '#512da8';
        case 5: return '#ffa000';
        case 6: return '#00796b';
        case 7: return '#000000';
        case 8: return '#7b1fa2';
        default: return '#000000';
      }
    }

    function openSurrounding(x, y) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            const neighbor = board[ny][nx];
            if (!neighbor.open && !neighbor.mine && !neighbor.flag) {
              openCell(neighbor);
              if (neighbor.count === 0) {
                openSurrounding(nx, ny);
              }
            }
          }
        }
      }
    }

    function endGame(win) {
      gameOver = true;
      clearInterval(timer);
      if (win) {
        statusEl.textContent = `ğŸ‰ å‹åˆ©ï¼ æ™‚é–“: ${timerSeconds}ç§’`;
      } else {
        statusEl.textContent = `ğŸ’¥ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼`;
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const cell = board[y][x];
            if (cell.mine && !cell.open) {
              cell.el.classList.add('mine');
              cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
            }
          }
        }
      }
    }

    init();
  </script>

  <!-- ãƒ­ã‚¸ãƒƒã‚¯ã‚½ãƒ«ãƒãƒ¼ï¼šæ•°å­—ã ã‘ã‹ã‚‰ {0,1,2} ã®å¯èƒ½é›†åˆã‚’çµã‚‹ï¼‹ä¸Šä½3å®‰å…¨ãƒã‚¹ -->
<script>
(function() {
  // ä½•å›ã€Œåˆ¶ç´„ä¼æ’­ã€ã‚’å›ã™ã‹ï¼ˆå¤§ããã™ã‚‹ã¨å°‘ã—ã ã‘å¼·ããªã‚‹ãŒã€ãã®åˆ†ã ã‘é‡ããªã‚‹ï¼‰
  const MAX_PROP_ITER = 10;

  // ãƒ’ãƒ³ãƒˆã®ã‚¯ãƒªã‚¢
  window.clearHints = function() {
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const c = board[y][x];
        c.el.classList.remove('logic-safe', 'logic-mine');
        if (!c.open && !c.flag) {
          c.el.textContent = '';
        }
        c.el.title = '';
      }
    }
  };

  // æ•°å­—ãƒã‚¹ï¼ˆopen & è¡¨ç¤ºã‚ã‚Š & >0ï¼‰ã‹ã‚‰åˆ¶ç´„ãƒªã‚¹ãƒˆã‚’ä½œã‚‹
  function getConstraints() {
    const constraints = [];
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const c = board[y][x];
        if (!c.open) continue;
        if (!c.el.textContent) continue;

        const d = parseInt(c.el.textContent, 10);
        if (isNaN(d) || d <= 0) continue;

        const neighbors = [];
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx, ny = y + dy;
            if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
            neighbors.push(board[ny][nx]);
          }
        }
        constraints.push({ display: d, neighbors });
      }
    }
    return constraints;
  }

  // å„ãƒã‚¹ã®ãƒ‰ãƒ¡ã‚¤ãƒ³ domain[y][x] = [can0, can1, can2]
  function initDomains() {
    const domain = [];
    for (let y = 0; y < size; y++) {
      domain[y] = [];
      for (let x = 0; x < size; x++) {
        const c = board[y][x];
        if (c.open) {
          // é–‹ã„ã¦ã„ã‚‹ãƒã‚¹ã¯å¿…ãšå®‰å…¨ï¼ˆ0ï¼‰
          domain[y][x] = [true, false, false];
        } else {
          // é–‰ã˜ã¦ã„ã‚‹ãƒã‚¹ã¯ 0,1,2 ã™ã¹ã¦ã‚ã‚Šå¾—ã‚‹
          domain[y][x] = [true, true, true];
        }
      }
    }
    return domain;
  }

  // 1 ã¤ã®åˆ¶ç´„ cons ã§ã€å„ neighbor ã®ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’å‰Šã‚‹
  function propagateConstraint(cons, domain) {
    let changed = false;
    const d = cons.display;

    // äº‹å‰ã« neighbors ã”ã¨ã® min/max ã‚’è¨ˆç®—ã—ã¦ãŠã
    const mins = [];
    const maxs = [];
    for (let i = 0; i < cons.neighbors.length; i++) {
      const c = cons.neighbors[i];
      const dom = domain[c.y][c.x];
      const vals = [];
      for (let v = 0; v <= 2; v++) if (dom[v]) vals.push(v);
      if (vals.length === 0) {
        // ã™ã§ã«çŸ›ç›¾ã—ã¦ã„ã‚‹ãŒã€ã“ã“ã§ã¯ä½•ã‚‚ã—ãªã„
        mins[i] = 0;
        maxs[i] = 0;
      } else {
        mins[i] = Math.min(...vals);
        maxs[i] = Math.max(...vals);
      }
    }

    for (let idx = 0; idx < cons.neighbors.length; idx++) {
      const c = cons.neighbors[idx];
      const dom = domain[c.y][c.x];

      // ã‚‚ã¨ã‚‚ã¨ã®å€™è£œã‚’è¦šãˆã¦ãŠã
      const original = dom.slice();
      const allowed = [false, false, false];

      for (let v = 0; v <= 2; v++) {
        if (!original[v]) continue;

        // ã“ã®ã‚»ãƒ«ã‚’ v ã¨ã—ãŸã¨ãã«ã€ä»–ãŒä½•ã‹ã—ã‚‰ã®å€¤ã‚’å–ã£ã¦
        // åˆè¨ˆ S âˆˆ {d, d+1} ã‚’ä½œã‚Œã‚‹ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
        let feasible = false;

        // ä»–ã®ã‚»ãƒ«ã® min/max
        let otherMin = 0;
        let otherMax = 0;
        for (let j = 0; j < cons.neighbors.length; j++) {
          if (j === idx) continue;
          otherMin += mins[j];
          otherMax += maxs[j];
        }

        for (const S of [d, d + 1]) {
          // S ã‹ã‚‰ã“ã®ã‚»ãƒ«ã® v ã‚’å¼•ã„ãŸæ®‹ã‚Šã‚’ã€ä»–ã®ã‚»ãƒ«ã§ä½œã‚Œã‚‹ã‹ï¼Ÿ
          const rest = S - v;
          if (rest < otherMin || rest > otherMax) {
            continue; // ã“ã® S ã§ã¯ç„¡ç†
          }
          // ä»–ã®ã‚»ãƒ«ã®å€¤ã¯ 0/1/2 ã®ãƒ¬ãƒ³ã‚¸ãªã®ã§ã€
          // ã€Œrest ãŒ [otherMin, otherMax] ã«å…¥ã£ã¦ã„ã‚‹ã€ãªã‚‰
          // ä½•ã‹ã—ã‚‰ã®çµ„ã¿åˆã‚ã›ã¯ã‚ã‚‹ã€ã¨ã¿ãªã™ï¼ˆéå°ã§ã¯ãªãéå¤§è©•ä¾¡ï¼‰
          feasible = true;
          break;
        }

        if (feasible) {
          allowed[v] = true;
        }
      }

      // allowed ãŒã™ã¹ã¦ false ã«ãªã‚‹å ´åˆã¯ã€ã€Œã“ã®åˆ¶ç´„ã ã‘ã§ã¯çŸ›ç›¾ã€ã¨ã„ã†ã ã‘ãªã®ã§ã€
      // ã“ã“ã§ã¯ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’å£Šã•ãªã„
      if (!allowed[0] && !allowed[1] && !allowed[2]) {
        continue;
      }

      for (let v = 0; v <= 2; v++) {
        if (!allowed[v] && dom[v]) {
          dom[v] = false;
          changed = true;
        }
      }
    }

    return changed;
  }

  // åˆ¶ç´„å…¨ä½“ã‚’ MAX_PROP_ITER å›ã¾ã§å›ã—ã¦ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’åæŸã•ã›ã‚‹
  function propagateAll(constraints, domain) {
    let changed = true;
    let iter = 0;
    while (changed && iter < MAX_PROP_ITER) {
      changed = false;
      iter++;
      for (const cons of constraints) {
        if (propagateConstraint(cons, domain)) {
          changed = true;
        }
      }
    }
  }

  // ãƒ¡ã‚¤ãƒ³ï¼šè‡ªå‹•ãƒ’ãƒ³ãƒˆè¡¨ç¤º
  window.showHint = function() {
    if (gameOver) return;

    clearHints();

    const constraints = getConstraints();
    if (constraints.length === 0) {
      statusEl.textContent = 'ã¾ã æ•°å­—ãŒé–‹ã„ã¦ã„ãªã„ã®ã§ã€ä½•ã‚‚æ¨è«–ã§ãã¾ã›ã‚“ã€‚';
      return;
    }

    const domain = initDomains();
    propagateAll(constraints, domain);

    // å„ã‚»ãƒ«ã®ã€Œå®‰å…¨ç¢ºå®š / åœ°é›·ç¢ºå®šã€ã‚’åˆ¤å®š
    const safeKeys = [];
    const mineKeys = [];
    const safeProbMap = new Map(); // key => safeProbï¼ˆä¸Šä½3ç”¨ï¼‰

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const c = board[y][x];
        if (c.open || c.flag) continue;

        const dom = domain[y][x];
        const key = `${x}_${y}`;

        const possible = [];
        for (let v = 0; v <= 2; v++) if (dom[v]) possible.push(v);

        if (possible.length === 0) {
          // çŸ›ç›¾ã—ã¦ã„ã‚‹ã ã‘ãªã®ã§ã€ã¨ã‚Šã‚ãˆãš 1/3 ã¨ã—ã¦ãŠã
          safeProbMap.set(key, 1/3);
          continue;
        }

        // å®‰å…¨ç¢ºå®š / åœ°é›·ç¢ºå®š
        const only0   = (possible.length === 1 && possible[0] === 0);
        const no0     = !dom[0] && (dom[1] || dom[2]); // 1 or 2 ã®ã¿

        if (only0) {
          safeKeys.push(key);
        } else if (no0) {
          mineKeys.push(key);
        }

        // ç°¡æ˜“ãªå®‰å…¨ç¢ºç‡ï¼šãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’ä¸€æ§˜åˆ†å¸ƒã¨ã¿ãªã™
        let mineVals = 0;
        for (const v of possible) if (v > 0) mineVals++;
        const safeProb = 1 - mineVals / possible.length;
        safeProbMap.set(key, safeProb);
      }
    }

    // ã¾ãšã€Œè«–ç†çš„ã« 100%ã€ã®ãƒã‚¹ã‚’ãƒãƒ¼ã‚¯
    let safeCount = 0;
    let mineCount = 0;

    for (const key of safeKeys) {
      const [xStr, yStr] = key.split('_');
      const x = Number(xStr), y = Number(yStr);
      const c = board[y][x];
      c.el.classList.add('logic-safe');
      c.el.title = 'è«–ç†çš„ã«å®‰å…¨ãŒç¢ºå®šã—ã¦ã„ã¾ã™';
      safeCount++;
    }
    for (const key of mineKeys) {
      const [xStr, yStr] = key.split('_');
      const x = Number(xStr), y = Number(yStr);
      const c = board[y][x];
      c.el.classList.add('logic-mine');
      c.el.title = 'è«–ç†çš„ã«åœ°é›·ãŒç¢ºå®šã—ã¦ã„ã¾ã™ï¼ˆæ™®é€š or é‡çˆ†ï¼‰';
      mineCount++;
    }

    // ä¸€ã¤ã‚‚ç¢ºå®šã—ãªã‹ã£ãŸã‚‰ã€å®‰å…¨ãã†ãªä¸Šä½3ãƒã‚¹ã‚’è¡¨ç¤º
    if (safeCount === 0 && mineCount === 0) {
      const candidates = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (c.open || c.flag) continue;
          const key = `${x}_${y}`;
          const p = safeProbMap.get(key);
          if (p == null) continue;
          candidates.push({ x, y, p });
        }
      }

      candidates.sort((a, b) => b.p - a.p);
      const top = candidates.slice(0, 3);

      for (const t of top) {
        const c = board[t.y][t.x];
        c.el.classList.add('logic-safe');
        c.el.textContent = `${Math.round(t.p * 100)}%`;
        c.el.title = `å®‰å…¨å€™è£œï¼ˆæ¨å®šå®‰å…¨ç¢ºç‡: ${(t.p * 100).toFixed(1)}%ï¼‰`;
      }

      statusEl.textContent =
        'åˆ¶ç´„ã‚’ ' + MAX_PROP_ITER + ' å›ä¼æ’­ã—ã¾ã—ãŸãŒã€\n' +
        'è«–ç†çš„ã« 100% å®‰å…¨ / 100% åœ°é›·ã«ãªã‚‹ãƒã‚¹ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\n' +
        'å®‰å…¨ãã†ãªå€™è£œ ä¸Šä½3ãƒã‚¹ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚';
    } else {
      statusEl.textContent =
        `è«–ç†çš„ã«å®‰å…¨ç¢ºå®š: ${safeCount} ãƒã‚¹\n` +
        `è«–ç†çš„ã«åœ°é›·ç¢ºå®š: ${mineCount} ãƒã‚¹`;
    }
  };
})();
</script>

</body>
</html>
