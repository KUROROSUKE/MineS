<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #f0f0f0;
      padding: 10px;
      user-select: none;
    }
    h1 {
      font-size: 24px;
      margin: 10px 0;
    }
    #controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    button {
      padding: 12px 24px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #2196f3;
      color: white;
    }
    button.flag-mode {
      background: #ff9800;
    }
    #status {
      font-size: 18px;
      font-weight: bold;
      margin-top: 10px;
      text-align: center;
      white-space: pre-line;
    }
    #board {
      display: grid;
      gap: 2px;
      box-sizing: border-box;
      margin: 0 auto;
      transition: all 0.2s ease-in-out;
    }
    .cell {
      background: #bbb;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      color: #333;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s, box-shadow 0.2s;
      aspect-ratio: 1 / 1;
      user-select: none;
    }
    .cell.open {
      background: #e0e0e0;
    }
    .cell.flag {
      background: #ffeb3b;
      color: #d32f2f;
    }
    .cell.mine {
      background: #f44336;
      color: white;
    }
    .timer {
      font-size: 20px;
      font-weight: bold;
      margin-top: 10px;
    }

    /* â–¼ ãƒ’ãƒ³ãƒˆè¡¨ç¤ºç”¨ã®è£…é£¾ â–¼ */
    .cell.logic-safe {
      box-shadow: 0 0 0 3px #4caf50 inset; /* ç·‘æ ï¼šå®‰å…¨ç¢ºå®š */
    }
    .cell.logic-mine {
      box-shadow: 0 0 0 3px #f44336 inset; /* èµ¤æ ï¼šåœ°é›·ç¢ºå®š */
    }
    .cell.logic-prob {
      box-shadow: 0 0 0 2px #9e9e9e inset; /* ã‚°ãƒ¬ãƒ¼æ ï¼šç¢ºç‡è¡¨ç¤º */
      font-size: 11px;
    }

    @media (max-width: 600px) {
      button {
        font-size: 16px;
        padding: 10px 20px;
      }
      h1 {
        font-size: 20px;
      }
      #status, .timer {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <h1>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</h1>
  <h2>1ãƒã‚¹ã§çˆ†å¼¾2å€‹åˆ†ã‚«ã‚¦ãƒ³ãƒˆã®é‡çˆ†å¼¾ãŒç´›ã‚Œè¾¼ã‚“ã§ã„ã‚‹ã€‚<br>ã¾ãŸã€æœ¬æ¥ã‚ˆã‚Š1å°‘ãªãè¡¨ç¤ºã•ã‚Œã‚‹å ´åˆãŒã‚ã‚‹ã€‚ï¼ˆæœ€å°å€¤1ï¼‰</h2>

  <div id="controls">
    <button id="flagButton">ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ OFF</button>
    <button id="resetButton">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
  </div>
  <div id="status"></div>
  <div id="board"></div>
  <div id="timer" class="timer">æ™‚é–“: 0</div>

  <!-- ã‚²ãƒ¼ãƒ æœ¬ä½“ -->
  <script>
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const flagButton = document.getElementById('flagButton');
    const resetButton = document.getElementById('resetButton');
    const timerEl = document.getElementById('timer');

    const size = 20;
    const mineCount = 100;
    const DECEPTION_PROBABILITY = 0.5; // 50%ã§è¡¨ç¤ºæ•°å€¤ã‚’-1ï¼ˆãŸã ã—æœ€å°1ï¼‰
    let gameOver = false;
    let flagMode = false;
    let openedCount = 0;
    let board = [];
    let timer;
    let timerSeconds = 0;
    let firstClick = null;

    flagButton.addEventListener('click', () => {
      flagMode = !flagMode;
      flagButton.textContent = flagMode ? 'ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ ON' : 'ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ OFF';
      flagButton.classList.toggle('flag-mode', flagMode);
    });

    resetButton.addEventListener('click', init);

    function requestHint() {
      if (typeof showHint === 'function' && !gameOver) {
        showHint();
      }
    }

    function init() {
      board = [];
      gameOver = false;
      openedCount = 0;
      firstClick = null;
      statusEl.textContent = '';
      boardEl.innerHTML = '';
      timerSeconds = 0;
      timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
      clearInterval(timer);
      timer = setInterval(() => {
        if (!gameOver) {
          timerSeconds++;
          timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
        }
      }, 1000);

      const shortSide = Math.min(window.innerWidth, window.innerHeight) * 0.9;
      boardEl.style.width = `${shortSide}px`;
      boardEl.style.height = `${shortSide}px`;
      boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      boardEl.style.gridTemplateRows = `repeat(${size}, 1fr)`;

      for (let y = 0; y < size; y++) {
        board[y] = [];
        for (let x = 0; x < size; x++) {
          const cellEl = document.createElement('div');
          cellEl.className = 'cell';
          cellEl.dataset.x = x;
          cellEl.dataset.y = y;
          boardEl.appendChild(cellEl);

          const cell = {
            x,
            y,
            mine: null, // null / "normal" / "heavy"
            open: false,
            flag: false,
            count: 0,
            el: cellEl
          };
          board[y][x] = cell;

          cellEl.addEventListener('click', () => handleCellClick(cell));
        }
      }

      if (typeof clearHints === 'function') clearHints();
    }

    function handleCellClick(cell) {
      if (gameOver) return;

      // æ——ãƒ¢ãƒ¼ãƒ‰æ™‚
      if (flagMode) {
        if (!cell.open) {
          if (typeof clearHints === 'function') clearHints();
          cell.flag = !cell.flag;
          cell.el.classList.toggle('flag', cell.flag);
          cell.el.textContent = cell.flag ? 'ğŸš©' : '';
          requestHint();
        }
        return;
      }

      // é€šå¸¸ã‚¯ãƒªãƒƒã‚¯
      if (cell.open || cell.flag) return;
      if (typeof clearHints === 'function') clearHints();

      // åˆã‚¯ãƒªãƒƒã‚¯ã§åœ°é›·é…ç½®
      if (!firstClick) {
        firstClick = { x: cell.x, y: cell.y };
        placeMines();
      }

      openCell(cell);

      if (cell.mine) {
        cell.el.classList.add('mine');
        cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
        endGame(false);
        return;
      }

      if (cell.count === 0) {
        openSurrounding(cell.x, cell.y);
      }

      if (openedCount === size * size - mineCount) {
        endGame(true);
        return;
      }

      requestHint();
    }

    function placeMines() {
      let mines = 0;
      const safeCells = new Set();

      // åˆæ‰‹ã¨ãã®å‘¨å›²ã¯å®‰å…¨
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = firstClick.x + dx;
          const ny = firstClick.y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            safeCells.add(`${nx},${ny}`);
          }
        }
      }

      const heavyMineCount = Math.floor(Math.random() * (mineCount + 1));
      let heavyMines = 0;

      while (mines < mineCount) {
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        const cell = board[y][x];
        if (!cell.mine && !safeCells.has(`${x},${y}`)) {
          if (heavyMines < heavyMineCount) {
            cell.mine = "heavy";
            heavyMines++;
          } else {
            cell.mine = "normal";
          }
          mines++;
        }
      }

      // æœ¬å½“ã®åˆè¨ˆã‚«ã‚¦ãƒ³ãƒˆï¼ˆé‡çˆ†å¼¾ã¯2ã‚«ã‚¦ãƒ³ãƒˆï¼‰
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (board[y][x].mine) continue;
          board[y][x].count = getMineCount(x, y);
        }
      }
    }

    function getMineCount(x, y) {
      let count = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            const mineType = board[ny][nx].mine;
            if (mineType === "normal") count += 1;
            else if (mineType === "heavy") count += 2;
          }
        }
      }
      return count;
    }

    function openCell(cell) {
      if (cell.open) return;
      cell.open = true;
      openedCount++;
      cell.el.classList.add('open');

      if (cell.count > 0) {
        let displayCount = cell.count;
        if (Math.random() < DECEPTION_PROBABILITY) {
          displayCount = Math.max(1, cell.count - 1);
        }
        cell.el.textContent = displayCount;
        cell.el.style.color = getNumberColor(displayCount);
      }

      if (openedCount === size * size - mineCount) {
        endGame(true);
      }
    }

    function getNumberColor(num) {
      switch (num) {
        case 1: return '#1976d2';
        case 2: return '#388e3c';
        case 3: return '#d32f2f';
        case 4: return '#512da8';
        case 5: return '#ffa000';
        case 6: return '#00796b';
        case 7: return '#000000';
        case 8: return '#7b1fa2';
        default: return '#000000';
      }
    }

    function openSurrounding(x, y) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            const neighbor = board[ny][nx];
            if (!neighbor.open && !neighbor.mine && !neighbor.flag) {
              openCell(neighbor);
              if (neighbor.count === 0) {
                openSurrounding(nx, ny);
              }
            }
          }
        }
      }
    }

    function endGame(win) {
      gameOver = true;
      clearInterval(timer);
      if (win) {
        statusEl.textContent = `ğŸ‰ å‹åˆ©ï¼ æ™‚é–“: ${timerSeconds}ç§’`;
      } else {
        statusEl.textContent = `ğŸ’¥ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼`;
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const cell = board[y][x];
            if (cell.mine && !cell.open) {
              cell.el.classList.add('mine');
              cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
            }
          }
        }
      }
    }

    init();
  </script>

  <!-- ãƒ’ãƒ³ãƒˆã‚½ãƒ«ãƒãƒ¼ï¼ˆè«–ç† + ç¢ºç‡ï¼‰ -->
  <script>
  (function() {
    const MAX_DEPTH = 13;
    const STATE = { SAFE: 0, MINE_NORMAL: 1, MINE_HEAVY: 2 };

    // ãƒ’ãƒ³ãƒˆã®ã‚¯ãƒªã‚¢
    window.clearHints = function() {
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          c.el.classList.remove('logic-safe', 'logic-mine', 'logic-prob');
          c.el.title = '';
          if (!c.open && !c.flag) {
            c.el.textContent = '';
          }
        }
      }
    };

    // å„æ•°å­—ãƒã‚¹å˜ä½ã§ã€Œè«–ç†çš„ã«ç¢ºå®šã™ã‚‹ã‚»ãƒ«ã€ã‚’æ±‚ã‚ã‚‹
    function findForcedCells() {
      const mustMine = new Set();
      const mustSafe = new Set();

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (!c.open) continue;
          if (c.el.textContent === '') continue;

          const d = parseInt(c.el.textContent);
          if (isNaN(d) || d <= 0) continue;

          const unknowns = [];
          let flagMin = 0;
          let flagMax = 0;

          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              const nx = x + dx, ny = y + dy;
              if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
              const n = board[ny][nx];

              if (n.open) continue;

              if (n.flag) {
                // æ——ã¯å¿…ãšåœ°é›·ï¼ˆ1ã€œ2ï¼‰
                flagMin += 1;
                flagMax += 2;
              } else {
                unknowns.push(n);
              }
            }
          }

          const k = unknowns.length;
          if (k === 0) continue;

          const safePossible = new Array(k).fill(false);
          const minePossible = new Array(k).fill(false);
          const vals = new Array(k).fill(0);

          function dfs(idx, sumU) {
            if (idx === k) {
              const minS = flagMin + sumU;
              const maxS = flagMax + sumU;
              const S1 = d;
              const S2 = d + 1; // æ¬ºçã§ +1 ã¾ã§ã‚ã‚Šå¾—ã‚‹

              const ok =
                (S1 >= minS && S1 <= maxS) ||
                (S2 >= minS && S2 <= maxS);

              if (!ok) return;

              for (let j = 0; j < k; j++) {
                const v = vals[j];
                if (v === 0) safePossible[j] = true;
                else minePossible[j] = true;
              }
              return;
            }

            for (let v = 0; v <= 2; v++) { // 0 / 1 / 2
              vals[idx] = v;
              dfs(idx + 1, sumU + v);
            }
          }

          dfs(0, 0);

          for (let j = 0; j < k; j++) {
            const key = `${unknowns[j].x}_${unknowns[j].y}`;
            const sOK = safePossible[j];
            const mOK = minePossible[j];

            if (sOK && !mOK) {
              mustSafe.add(key);   // åœ°é›·ã¯è«–ç†çš„ã«ä¸å¯èƒ½
            } else if (!sOK && mOK) {
              mustMine.add(key);   // å®‰å…¨ã¯è«–ç†çš„ã«ä¸å¯èƒ½
            }
          }
        }
      }
      return { mustMine, mustSafe };
    }

    // ç›¤é¢å…¨ä½“ã‚’ã‚¯ãƒ©ã‚¹ã‚¿ã«åˆ†ã‘ã¦ç¢ºç‡è§£æï¼ˆè«–ç†ã§æ±ºã¾ã‚‰ãªã„éƒ¨åˆ†ç”¨ï¼‰
    function analyzeBoard() {
      const frontier = getFrontierCells();
      if (frontier.length === 0) return [];

      const probabilityMap = {};
      frontier.forEach(c => {
        probabilityMap[`${c.x}_${c.y}`] = { safe: 0, total: 0 };
      });

      const constraints = getConstraints();
      const clusters = clusterByConstraints(frontier, constraints);

      for (let cluster of clusters) {
        let targetCells = cluster;
        if (cluster.length > MAX_DEPTH) {
          targetCells = cluster.slice(0, MAX_DEPTH);
        }
        solveCluster(targetCells, constraints, probabilityMap);
      }

      const results = [];
      for (let key in probabilityMap) {
        const data = probabilityMap[key];
        if (data.total > 0) {
          const [x, y] = key.split('_').map(Number);
          const safeProb = data.safe / data.total;
          const mineProb = 1 - safeProb;
          results.push({ x, y, safeProb, mineProb });
        }
      }
      return results;
    }

    function getFrontierCells() {
      const list = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (!c.open && !c.flag) {
            let hasOpenNeighbor = false;
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
                  if (board[ny][nx].open) {
                    hasOpenNeighbor = true;
                    break;
                  }
                }
              }
              if (hasOpenNeighbor) break;
            }
            if (hasOpenNeighbor) list.push(c);
          }
        }
      }
      return list;
    }

    function getConstraints() {
      const list = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (c.open && c.el.textContent !== '') {
            const d = parseInt(c.el.textContent);
            if (isNaN(d) || d <= 0) continue;

            const neighbors = [];
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < size && ny >= 0 && ny < size) {
                  neighbors.push(board[ny][nx]);
                }
              }
            }
            list.push({ x, y, display: d, neighbors });
          }
        }
      }
      return list;
    }

    function clusterByConstraints(frontierCells, constraints) {
      const cellToConstraints = new Map();
      frontierCells.forEach(c => cellToConstraints.set(c, []));

      constraints.forEach((cons, idx) => {
        cons.neighbors.forEach(n => {
          if (cellToConstraints.has(n)) {
            cellToConstraints.get(n).push(idx);
          }
        });
      });

      const visited = new Set();
      const clusters = [];

      for (let cell of frontierCells) {
        if (visited.has(cell)) continue;

        const cluster = [];
        const queue = [cell];
        visited.add(cell);

        while (queue.length > 0) {
          const curr = queue.shift();
          cluster.push(curr);

          const consIndices = cellToConstraints.get(curr) || [];
          for (let cIdx of consIndices) {
            const cons = constraints[cIdx];
            for (let neighbor of cons.neighbors) {
              if (frontierCells.includes(neighbor) && !visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
              }
            }
          }
          if (cluster.length >= MAX_DEPTH + 5) break;
        }
        clusters.push(cluster);
      }
      return clusters;
    }

    function solveCluster(cells, constraints, probMap) {
      const relevantConstraints = constraints.filter(c =>
        c.neighbors.some(n => cells.includes(n))
      );

      const assignment = new Map();

      function backtrack(index) {
        if (index === cells.length) {
          cells.forEach(c => {
            const k = `${c.x}_${c.y}`;
            probMap[k].total++;
            if (assignment.get(k) === STATE.SAFE) {
              probMap[k].safe++;
            }
          });
          return;
        }

        const cell = cells[index];
        const key = `${cell.x}_${cell.y}`;

        for (let state of [STATE.SAFE, STATE.MINE_NORMAL, STATE.MINE_HEAVY]) {
          assignment.set(key, state);
          if (isValid(relevantConstraints, assignment)) {
            backtrack(index + 1);
          }
        }
        assignment.delete(key);
      }

      backtrack(0);
    }

    // display ã¾ãŸã¯ display+1 ãŒå–ã‚Šå¾—ã‚‹ã‹ã‚’ã€ç¾çŠ¶å‰²å½“ã§ãƒã‚§ãƒƒã‚¯
    function isValid(constraints, assignment) {
      for (let c of constraints) {
        let currentSum = 0;
        let unknownCount = 0;
        let flagMin = 0;
        let flagMax = 0;

        for (let n of c.neighbors) {
          if (n.open) continue;

          if (n.flag) {
            flagMin += 1;
            flagMax += 2;
            continue;
          }

          const k = `${n.x}_${n.y}`;
          if (assignment.has(k)) {
            currentSum += assignment.get(k); // 0 / 1 / 2
          } else {
            unknownCount++;
          }
        }

        const d = c.display;
        if (isNaN(d)) continue;

        const minTotal = currentSum + flagMin;
        const maxTotal = currentSum + flagMax + unknownCount * 2;

        // çœŸã®åˆè¨ˆ S ã¯ display ã¾ãŸã¯ display+1
        if (maxTotal < d) return false;
        if (minTotal > d + 1) return false;
      }
      return true;
    }

    // ãƒ¡ã‚¤ãƒ³ï¼šè‡ªå‹•ãƒ’ãƒ³ãƒˆè¡¨ç¤º
    window.showHint = function() {
      if (gameOver) return;

      clearHints();

      // â‘  å„æ•°å­—ãƒã‚¹å˜ä½ã®å®Œå…¨è«–ç†æ¨è«–
      const { mustMine, mustSafe } = findForcedCells();

      // â‘¡ ãã‚Œã§ã‚‚æ±ºã¾ã‚‰ãªã„éƒ¨åˆ†ã ã‘ç¢ºç‡è§£æ
      const localMoves = analyzeBoard();
      const moveMap = new Map();
      for (const m of localMoves) {
        moveMap.set(`${m.x}_${m.y}`, m);
      }

      let forcedSafeCount = mustSafe.size;
      let forcedMineCount = mustMine.size;

      const probSafe100 = localMoves.filter(m => m.safeProb >= 0.999);
      const probMine100 = localMoves.filter(m => m.mineProb >= 0.999);

      // è¨ˆç®—ä¸Š 100% ã«ãªã£ãŸã‚‚ã®ã‚‚ã‚«ã‚¦ãƒ³ãƒˆ
      forcedSafeCount += probSafe100.length;
      forcedMineCount += probMine100.length;

      if (forcedSafeCount === 0 && forcedMineCount === 0) {
        statusEl.textContent =
          'è«–ç†çš„ã«ç¢ºå®šã§ãã‚‹ãƒã‚¹ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚\n' +
          'ä¸€éƒ¨ã®ãƒã‚¹ã«ã¯è¿‘å‚ã®åˆ¶ç´„ã‹ã‚‰ã®å®‰å…¨ç¢ºç‡ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚';
      } else {
        statusEl.textContent =
          `è«–ç†çš„ã«å®‰å…¨ç¢ºå®š: ${mustSafe.size} ãƒã‚¹\n` +
          `è«–ç†çš„ã«åœ°é›·ç¢ºå®š: ${mustMine.size} ãƒã‚¹\n` +
          'ãã®ã»ã‹ã®ãƒã‚¹ã«ã¯è¿‘å‚ã®åˆ¶ç´„ã‹ã‚‰ã®å®‰å…¨ç¢ºç‡ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚';
      }

      // â‘¢ ç›¤é¢å…¨ä½“ã«ãƒ’ãƒ³ãƒˆã‚’åæ˜ 
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.open || cell.flag) continue;

          const key = `${x}_${y}`;
          const prob = moveMap.get(key);

          let safeProb, mineProb;
          let fromLogic = false;

          if (mustMine.has(key)) {
            safeProb = 0;
            mineProb = 1;
            fromLogic = true;
          } else if (mustSafe.has(key)) {
            safeProb = 1;
            mineProb = 0;
            fromLogic = true;
          } else if (prob) {
            safeProb = prob.safeProb;
            mineProb = prob.mineProb;
            fromLogic = true;
          } else {
            // æ•°å­—ã‹ã‚‰ä½•ã®åˆ¶ç´„ã‚‚å—ã‘ã¦ã„ãªã„é ˜åŸŸï¼šä½•ã‚‚åˆ†ã‹ã‚‰ãªã„ã®ã§æš«å®š 50%
            safeProb = 0.5;
            mineProb = 0.5;
            fromLogic = false;
          }

          const safeP = safeProb;
          const mineP = mineProb;
          const keyText =
            `å®‰å…¨: ${(safeP * 100).toFixed(1)}% / åœ°é›·: ${(mineP * 100).toFixed(1)}%`;

          if (safeP >= 0.999) {
            cell.el.classList.add('logic-safe');
            cell.el.title = 'å®‰å…¨ç¢ºå®š\n' + keyText;
          } else if (mineP >= 0.999) {
            cell.el.classList.add('logic-mine');
            cell.el.title = 'åœ°é›·ç¢ºå®š\n' + keyText;
          } else {
            cell.el.classList.add('logic-prob');
            cell.el.textContent = `${Math.round(safeP * 100)}%`;
            cell.el.title = (fromLogic ? '' : 'å±€æ‰€æƒ…å ±ãªã—ãƒ»æš«å®šå€¤\n') + keyText;
          }
        }
      }
    };
  })();
  </script>
</body>
</html>
