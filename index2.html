<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ãƒ­ã‚¸ãƒƒã‚¯ä»˜ããƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #f0f0f0;
      padding: 10px;
      user-select: none;
    }
    h1 {
      font-size: 24px;
      margin: 10px 0;
    }
    #controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    button {
      padding: 12px 24px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #2196f3;
      color: white;
    }
    button.flag-mode {
      background: #ff9800;
    }
    #status {
      font-size: 18px;
      font-weight: bold;
      margin-top: 10px;
      text-align: center;
      white-space: pre-line;
    }
    #board {
      display: grid;
      gap: 2px;
      box-sizing: border-box;
      margin: 0 auto;
      transition: all 0.2s ease-in-out;
    }
    .cell {
      background: #bbb;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      color: #333;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s, box-shadow 0.2s;
      /* å¹…ãƒ»é«˜ã•ã¯ grid ã®ãƒˆãƒ©ãƒƒã‚¯ã‚µã‚¤ã‚ºã§å›ºå®šã™ã‚‹ã®ã§ aspect-ratio ã¯ä½¿ã‚ãªã„ */
      user-select: none;
    }
    .cell.open {
      background: #e0e0e0;
    }
    .cell.flag {
      background: #ffeb3b;
      color: #d32f2f;
    }
    .cell.mine {
      background: #f44336;
      color: white;
    }
    .timer {
      font-size: 20px;
      font-weight: bold;
      margin-top: 10px;
    }

    /* ãƒ’ãƒ³ãƒˆè¡¨ç¤ºç”¨ */
    .cell.logic-safe {
      box-shadow: 0 0 0 3px #4caf50 inset; /* ç·‘æ ï¼šå®‰å…¨ç¢ºå®š or å®‰å…¨å€™è£œ */
    }
    .cell.logic-mine {
      box-shadow: 0 0 0 3px #f44336 inset; /* èµ¤æ ï¼šåœ°é›·ç¢ºå®š */
    }
  </style>
</head>
<body>
  <h1>ãƒ­ã‚¸ãƒƒã‚¯ä»˜ããƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</h1>
  <h2>
    ãƒ»ä¸€éƒ¨ã®çˆ†å¼¾ã¯ã€Œé‡çˆ†å¼¾ã€ã§ã€å‘¨å›²ã« 2 å€‹åˆ†ã¨ã—ã¦æ•°ãˆä¸Šã’ã‚‰ã‚Œã‚‹ã€‚<br>
    ãƒ»è¡¨ç¤ºã•ã‚Œã‚‹æ•°å­—ã¯ã€æœ¬æ¥ã®åˆè¨ˆã‹ã‚‰ 1 å°‘ãªã„ã“ã¨ãŒã‚ã‚‹ï¼ˆãŸã ã— 1 æœªæº€ã«ã¯ãªã‚‰ãªã„ï¼‰ã€‚<br>
    ãƒ»æ——ï¼ˆğŸš©ï¼‰ã¯ãƒ¡ãƒ¢ç”¨ã€‚ãƒ­ã‚¸ãƒƒã‚¯ã¯æ•°å­—ã ã‘ã§æ¨è«–ã—ã¾ã™ã€‚<br>
    ãƒ»æ¯å›ã€è‡ªå‹•ã§æ¨è«–ã—ã¦å®‰å…¨/åœ°é›·ãŒç¢ºå®šã—ã¦ã„ã‚‹ãƒã‚¹ã‚’æ è¡¨ç¤ºã—ã¾ã™ã€‚<br>
    ãƒ»ä½•ã‚‚ç¢ºå®šã—ãªã„ã¨ãã¯ã€å®‰å…¨ãã†ãªä¸Šä½ 3 ãƒã‚¹ã«å®‰å…¨ç¢ºç‡ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
  </h2>

  <div id="controls">
    <button id="flagButton">ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ OFF</button>
    <button id="resetButton">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
  </div>
  <div id="status"></div>
  <div id="board"></div>
  <div id="timer" class="timer">æ™‚é–“: 0</div>

  <!-- ã‚²ãƒ¼ãƒ æœ¬ä½“ -->
  <script>
    const boardEl   = document.getElementById('board');
    const statusEl  = document.getElementById('status');
    const flagButton  = document.getElementById('flagButton');
    const resetButton = document.getElementById('resetButton');
    const timerEl   = document.getElementById('timer');

    const size = 20;
    const mineCount = 100;               // çˆ†å¼¾ã®å€‹æ•°ï¼ˆé‡çˆ†ã‚‚ 1 å€‹ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆï¼‰
    const DECEPTION_PROBABILITY = 0.5;   // 50%ã§è¡¨ç¤ºæ•°å€¤ã‚’-1ï¼ˆãŸã ã—æœ€å°1ï¼‰

    let gameOver    = false;
    let flagMode    = false;
    let openedCount = 0;
    let board       = [];
    let timer;
    let timerSeconds = 0;
    let firstClick  = null;

    flagButton.addEventListener('click', () => {
      flagMode = !flagMode;
      flagButton.textContent = flagMode ? 'ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ ON' : 'ğŸš© æ——ãƒ¢ãƒ¼ãƒ‰ OFF';
      flagButton.classList.toggle('flag-mode', flagMode);
    });

    resetButton.addEventListener('click', init);

    function requestHint() {
      if (typeof showHint === 'function' && !gameOver) {
        showHint();
      }
    }

    function init() {
      board = [];
      gameOver = false;
      openedCount = 0;
      firstClick = null;
      statusEl.textContent = '';
      boardEl.innerHTML = '';
      timerSeconds = 0;
      timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
      clearInterval(timer);
      timer = setInterval(() => {
        if (!gameOver) {
          timerSeconds++;
          timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
        }
      }, 1000);

      // ç”»é¢ã‚µã‚¤ã‚ºã‹ã‚‰ 1ãƒã‚¹ã®ãƒ”ã‚¯ã‚»ãƒ«æ•°ã‚’æ±ºå®šï¼ˆå…¨ãƒã‚¹åŒã˜æ­£æ–¹å½¢ã«ãªã‚‹ï¼‰
      const cellSize = Math.floor(
        Math.min(window.innerWidth, window.innerHeight) * 0.9 / size
      );

      boardEl.style.width  = `${cellSize * size}px`;
      boardEl.style.height = `${cellSize * size}px`;
      boardEl.style.gridTemplateColumns = `repeat(${size}, ${cellSize}px)`;
      boardEl.style.gridTemplateRows    = `repeat(${size}, ${cellSize}px)`;

      for (let y = 0; y < size; y++) {
        board[y] = [];
        for (let x = 0; x < size; x++) {
          const cellEl = document.createElement('div');
          cellEl.className = 'cell';
          cellEl.dataset.x = x;
          cellEl.dataset.y = y;
          boardEl.appendChild(cellEl);

          const cell = {
            x,
            y,
            mine: null,   // null / "normal" / "heavy"ï¼ˆå†…éƒ¨ã ã‘ã§ä½¿ç”¨ï¼‰
            open: false,
            flag: false,
            count: 0,     // çœŸã®åˆè¨ˆï¼ˆé‡çˆ†ã¯2ã‚«ã‚¦ãƒ³ãƒˆï¼‰
            el: cellEl
          };
          board[y][x] = cell;

          cellEl.addEventListener('click', () => handleCellClick(cell));
        }
      }

      if (typeof clearHints === 'function') clearHints();
    }

    function handleCellClick(cell) {
      if (gameOver) return;

      // æ——ãƒ¢ãƒ¼ãƒ‰ï¼šON ã®ã¨ãã¯æ——ã® ON/OFF ã ã‘
      if (flagMode) {
        if (!cell.open) {
          if (typeof clearHints === 'function') clearHints();
          cell.flag = !cell.flag;
          cell.el.classList.toggle('flag', cell.flag);
          cell.el.textContent = cell.flag ? 'ğŸš©' : '';
          requestHint();
        }
        return;
      }

      // é€šå¸¸ã‚¯ãƒªãƒƒã‚¯
      if (cell.open || cell.flag) return;
      if (typeof clearHints === 'function') clearHints();

      // åˆã‚¯ãƒªãƒƒã‚¯ã§åœ°é›·é…ç½®
      if (!firstClick) {
        firstClick = { x: cell.x, y: cell.y };
        placeMines();
      }

      openCell(cell);

      if (cell.mine) {
        cell.el.classList.add('mine');
        cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
        endGame(false);
        return;
      }

      if (cell.count === 0) {
        openSurrounding(cell.x, cell.y);
      }

      if (openedCount === size * size - mineCount) {
        endGame(true);
        return;
      }

      requestHint();
    }

    function placeMines() {
      let mines = 0;
      const safeCells = new Set();

      // åˆæ‰‹ã¨ãã®å‘¨å›²ã¯å®‰å…¨
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = firstClick.x + dx;
          const ny = firstClick.y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            safeCells.add(`${nx},${ny}`);
          }
        }
      }

      const heavyMineCount = Math.floor(Math.random() * (mineCount + 1));
      let heavyMines = 0;

      while (mines < mineCount) {
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        const cell = board[y][x];
        if (!cell.mine && !safeCells.has(`${x},${y}`)) {
          if (heavyMines < heavyMineCount) {
            cell.mine = "heavy";
            heavyMines++;
          } else {
            cell.mine = "normal";
          }
          mines++;
        }
      }

      // çœŸã®åˆè¨ˆã‚«ã‚¦ãƒ³ãƒˆï¼ˆé‡çˆ†å¼¾ã¯2ã‚«ã‚¦ãƒ³ãƒˆï¼‰
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (board[y][x].mine) continue;
          board[y][x].count = getMineCount(x, y);
        }
      }
    }

    function getMineCount(x, y) {
      let count = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            const mineType = board[ny][nx].mine;
            if (mineType === "normal") count += 1;
            else if (mineType === "heavy") count += 2;
          }
        }
      }
      return count;
    }

    function openCell(cell) {
      if (cell.open) return;
      cell.open = true;
      openedCount++;
      cell.el.classList.add('open');

      if (cell.count > 0) {
        let displayCount = cell.count;
        if (Math.random() < DECEPTION_PROBABILITY) {
          displayCount = Math.max(1, cell.count - 1);
        }
        cell.el.textContent = displayCount;
        cell.el.style.color = getNumberColor(displayCount);
      }

      if (openedCount === size * size - mineCount) {
        endGame(true);
      }
    }

    function getNumberColor(num) {
      switch (num) {
        case 1: return '#1976d2';
        case 2: return '#388e3c';
        case 3: return '#d32f2f';
        case 4: return '#512da8';
        case 5: return '#ffa000';
        case 6: return '#00796b';
        case 7: return '#000000';
        case 8: return '#7b1fa2';
        default: return '#000000';
      }
    }

    function openSurrounding(x, y) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            const neighbor = board[ny][nx];
            if (!neighbor.open && !neighbor.mine && !neighbor.flag) {
              openCell(neighbor);
              if (neighbor.count === 0) {
                openSurrounding(nx, ny);
              }
            }
          }
        }
      }
    }

    function endGame(win) {
      gameOver = true;
      clearInterval(timer);
      if (win) {
        statusEl.textContent = `ğŸ‰ å‹åˆ©ï¼ æ™‚é–“: ${timerSeconds}ç§’`;
      } else {
        statusEl.textContent = `ğŸ’¥ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼`;
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const cell = board[y][x];
            if (cell.mine && !cell.open) {
              cell.el.classList.add('mine');
              cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
            }
          }
        }
      }
    }

    init();
  </script>

  <!-- ãƒ­ã‚¸ãƒƒã‚¯ã‚½ãƒ«ãƒãƒ¼ï¼šæ•°å­—ã ã‘ã‹ã‚‰ 0/1/2 ã‚’æ·±ã•åˆ¶é™ä»˜ãã§å…¨æ¢ç´¢ -->
  <script>
  (function() {
    // ãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢å…¨ä½“ã§æ‰±ã†æœ€å¤§å¤‰æ•°æ•°ï¼ˆ3^13 â‰’ 160ä¸‡ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
    const MAX_VARS_GLOBAL = 13;

    // ãƒ’ãƒ³ãƒˆã®ã‚¯ãƒªã‚¢
    window.clearHints = function() {
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          c.el.classList.remove('logic-safe', 'logic-mine');
          if (!c.open && !c.flag) {
            c.el.textContent = '';
          }
          c.el.title = '';
        }
      }
    };

    // æ•°å­—ãƒã‚¹ï¼ˆopen & è¡¨ç¤ºã‚ã‚Š & >0ï¼‰ã‹ã‚‰åˆ¶ç´„ãƒªã‚¹ãƒˆã‚’ä½œã‚‹
    function getConstraints() {
      const constraints = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (!c.open) continue;
          if (!c.el.textContent) continue;

          const d = parseInt(c.el.textContent, 10);
          if (isNaN(d) || d <= 0) continue;

          const neighbors = [];
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              const nx = x + dx, ny = y + dy;
              if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
              const n = board[ny][nx];
              if (!n.open) {
                neighbors.push(n); // é–‰ã˜ã¦ã„ã‚‹ãƒã‚¹ï¼ˆæ——ã‚‚å«ã‚€ï¼‰ã¯å…¨éƒ¨å€™è£œ
              }
            }
          }
          if (neighbors.length > 0) {
            constraints.push({ display: d, neighbors });
          }
        }
      }
      return constraints;
    }

    // ãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢ = ã™ã¹ã¦ã®åˆ¶ç´„ã®éš£æ¥ã«ç¾ã‚Œã‚‹é–‰ã˜ãƒã‚¹
    function getFrontierCells(constraints) {
      const keySet = new Set();
      function key(c) { return c.x + "_" + c.y; }

      for (const cons of constraints) {
        for (const n of cons.neighbors) {
          keySet.add(key(n));
        }
      }

      const frontier = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          const k = x + "_" + y;
          if (keySet.has(k)) {
            frontier.push(c);
          }
        }
      }
      return frontier;
    }

    // éƒ¨åˆ†å‰²ã‚Šå½“ã¦ãŒåˆ¶ç´„ã¨çŸ›ç›¾ã—ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆ0/1/2 ã®ç¯„å›²ã§ï¼‰
    function isPartialValid(assign, constraints) {
      for (const cons of constraints) {
        const d = cons.display;
        let sum = 0;
        let unassigned = 0;

        for (const idx of cons.indices) {
          const v = assign[idx];
          if (v == null) {
            unassigned++;
          } else {
            sum += v;
          }
        }

        const minTotal = sum;
        const maxTotal = sum + 2 * unassigned;

        // çœŸã®åˆè¨ˆ S ã¯ d ã¾ãŸã¯ d+1
        if (maxTotal < d)   return false;
        if (minTotal > d+1) return false;
      }
      return true;
    }

    // å®Œå…¨å‰²ã‚Šå½“ã¦ãŒå…¨åˆ¶ç´„ã‚’æº€ãŸã™ã‹ãƒã‚§ãƒƒã‚¯
    function isFullValid(assign, constraints) {
      for (const cons of constraints) {
        const d = cons.display;
        let sum = 0;
        for (const idx of cons.indices) {
          sum += assign[idx]; // 0/1/2 å…¨éƒ¨æ±ºã¾ã£ã¦ã„ã‚‹å‰æ
        }
        if (!(sum === d || sum === d + 1)) {
          return false;
        }
      }
      return true;
    }

    // ãƒ¡ã‚¤ãƒ³ï¼šè‡ªå‹•ãƒ’ãƒ³ãƒˆè¡¨ç¤º
    window.showHint = function() {
      if (gameOver) return;

      clearHints();

      const constraints = getConstraints();
      if (constraints.length === 0) {
        statusEl.textContent = 'ã¾ã æ•°å­—ãŒé–‹ã„ã¦ã„ãªã„ã®ã§ã€ä½•ã‚‚æ¨è«–ã§ãã¾ã›ã‚“ã€‚';
        return;
      }

      const frontier = getFrontierCells(constraints);
      const N = frontier.length;

      // ãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢ãŒå¤šã™ãã‚‹ã¨ãã¯ã€è«–ç†æ¨è«–ã¯è«¦ã‚ã¦ç¢ºç‡ã ã‘ã«ã™ã‚‹
      let useSearch = true;
      if (N === 0) {
        useSearch = false;
      } else if (N > MAX_VARS_GLOBAL) {
        useSearch = false;
      }

      // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã–ã£ãã‚Šç¢ºç‡ï¼ˆæ•°å­—ã«è§¦ã‚Œã¦ã„ãªã„ãƒã‚¹ç”¨ï¼‹ãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢ãŒå¤§ãã™ãã‚‹ã¨ãï¼‰
      const totalCells = size * size;
      const unknownCells = totalCells - openedCount;
      let globalSafeProb = 0.5;
      if (unknownCells > 0) {
        const globalMineProb = mineCount / unknownCells;
        globalSafeProb = Math.max(0, Math.min(1, 1 - globalMineProb));
      }

      // å„ãƒã‚¹ã® safe/total ã¨ 0/1/2 ã‚’å–ã‚Šå¾—ãŸã‹ã©ã†ã‹
      const probMap = new Map(); // key -> {safe,total,values[3]}
      for (const c of frontier) {
        probMap.set(c.x + "_" + c.y, {
          safe: 0,
          total: 0,
          values: [false, false, false]
        });
      }

      if (useSearch) {
        // frontier ã®ã‚»ãƒ«ã‚’ 0..N-1 ã«å‰²ã‚ŠæŒ¯ã‚Š
        const varIndex = new Map();
        frontier.forEach((c, i) => varIndex.set(c, i));

        // åˆ¶ç´„ã‚’ varIndex ã® index ã«å¤‰æ›
        const cons2 = [];
        for (const cons of constraints) {
          const idxs = [];
          for (const n of cons.neighbors) {
            idxs.push(varIndex.get(n));
          }
          cons2.push({ display: cons.display, indices: idxs });
        }

        const assign = new Array(N).fill(null);

        function backtrack(pos) {
          if (pos === N) {
            if (!isFullValid(assign, cons2)) return;
            // è§£ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆ
            for (let i = 0; i < N; i++) {
              const c = frontier[i];
              const key = c.x + "_" + c.y;
              const rec = probMap.get(key);
              const v = assign[i]; // 0/1/2
              rec.total++;
              if (v === 0) rec.safe++;
              rec.values[v] = true;
            }
            return;
          }

          for (let v = 0; v <= 2; v++) {
            assign[pos] = v;
            if (isPartialValid(assign, cons2)) {
              backtrack(pos + 1);
            }
            assign[pos] = null;
          }
        }

        backtrack(0);
      }

      // å„ãƒã‚¹ã®å®‰å…¨ç¢ºç‡ / ç¢ºå®šæƒ…å ±ã‚’ã¾ã¨ã‚ã‚‹
      const cellSafeProb = new Map(); // key -> safeProb
      const forcedSafe = new Set();
      const forcedMine = new Set();

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (c.open || c.flag) continue;

          const key = x + "_" + y;
          const rec = probMap.get(key);

          if (rec && rec.total > 0) {
            const safeProb = rec.safe / rec.total;
            cellSafeProb.set(key, safeProb);

            const can0 = rec.values[0];
            const can1 = rec.values[1];
            const can2 = rec.values[2];

            if (can0 && !can1 && !can2) {
              // 0 ã—ã‹å–ã‚Šå¾—ãªã„ â†’ å®‰å…¨
              forcedSafe.add(key);
            } else if (!can0 && (can1 || can2)) {
              // 1/2 ã—ã‹å–ã‚Šå¾—ãªã„ â†’ åœ°é›·ï¼ˆæ™®é€š or é‡çˆ†ï¼‰ç¢ºå®š
              forcedMine.add(key);
            }
          } else {
            // æ¢ç´¢ã—ã¦ã„ãªã„ or ã“ã®ã‚»ãƒ«ã¯åˆ¶ç´„ã«å‡ºã¦ã“ãªã„ â†’ ã‚°ãƒ­ãƒ¼ãƒãƒ«ç¢ºç‡ã‚’ä½¿ã†
            cellSafeProb.set(key, globalSafeProb);
          }
        }
      }

      // ã¾ãšã¯è«–ç†çš„ã« 0% / 100% ãŒå‡ºãŸã¨ã“ã‚
      let safeCount = 0;
      let mineCount = 0;

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          if (c.open || c.flag) continue;
          const key = x + "_" + y;

          if (forcedSafe.has(key)) {
            c.el.classList.add('logic-safe');
            c.el.title = 'è«–ç†çš„ã«å®‰å…¨ãŒç¢ºå®šã—ã¦ã„ã¾ã™ï¼ˆã©ã®è§£ã§ã‚‚ 0ï¼‰';
            safeCount++;
          } else if (forcedMine.has(key)) {
            c.el.classList.add('logic-mine');
            c.el.title = 'è«–ç†çš„ã«åœ°é›·ãŒç¢ºå®šã—ã¦ã„ã¾ã™ï¼ˆã©ã®è§£ã§ã‚‚ 1 or 2ï¼‰';
            mineCount++;
          }
        }
      }

      // ä½•ã‚‚ç¢ºå®šã—ãªã‹ã£ãŸã‚‰ã€å®‰å…¨ãã†ãªä¸Šä½3ãƒã‚¹ã‚’è¡¨ç¤º
      if (safeCount === 0 && mineCount === 0) {
        const candidates = [];
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const c = board[y][x];
            if (c.open || c.flag) continue;
            const key = x + "_" + y;
            const p = cellSafeProb.get(key);
            if (p == null) continue;
            candidates.push({ x, y, p });
          }
        }

        candidates.sort((a, b) => b.p - a.p);
        const top = candidates.slice(0, 3);

        for (const t of top) {
          const c = board[t.y][t.x];
          c.el.classList.add('logic-safe');
          c.el.textContent = `${Math.round(t.p * 100)}%`;
          c.el.title = `å®‰å…¨å€™è£œï¼ˆæ¨å®šå®‰å…¨ç¢ºç‡: ${(t.p * 100).toFixed(1)}%ï¼‰`;
        }

        if (!useSearch) {
          statusEl.textContent =
            `æ•°å­—ã®éš£æ¥ãƒã‚¹ãŒå¤šã™ãã‚‹ãŸã‚ï¼ˆ${N}ãƒã‚¹ï¼‰ã€\n` +
            `è«–ç†æ¨è«–ã¯ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸã€‚\n` +
            `ã–ã£ãã‚Šæ¨å®šã®å®‰å…¨å€™è£œ ä¸Šä½3ãƒã‚¹ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚`;
        } else {
          statusEl.textContent =
            '0/1/2 ã®å…¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã€ãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢ ' + N + ' ãƒã‚¹ã«å¯¾ã—ã¦èª¿ã¹ã¾ã—ãŸãŒã€\n' +
            'è«–ç†çš„ã« 100% å®‰å…¨ / 100% åœ°é›·ã«ãªã‚‹ãƒã‚¹ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\n' +
            'å®‰å…¨ãã†ãªå€™è£œ ä¸Šä½3ãƒã‚¹ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚';
        }
      } else {
        if (!useSearch) {
          statusEl.textContent =
            `æ•°å­—ã®éš£æ¥ãƒã‚¹ãŒå¤šã™ãã‚‹ãŸã‚ï¼ˆ${N}ãƒã‚¹ï¼‰ã€\n` +
            `è«–ç†æ¨è«–ã¯ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸã€‚\n` +
            `â€» ä»Šå›ã¯ãŸã¾ãŸã¾ç¢ºå®šãƒã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸãŒã€ä»Šå¾Œã¯ç¢ºç‡ãƒ’ãƒ³ãƒˆä¸­å¿ƒã«ãªã‚Šã¾ã™ã€‚`;
        } else {
          statusEl.textContent =
            `è«–ç†çš„ã«å®‰å…¨ç¢ºå®š: ${safeCount} ãƒã‚¹\n` +
            `è«–ç†çš„ã«åœ°é›·ç¢ºå®š: ${mineCount} ãƒã‚¹\n` +
            `ï¼ˆãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢ ${N} ãƒã‚¹ã«å¯¾ã—ã¦ 0/1/2 å…¨æ¢ç´¢æ¸ˆã¿ã€‚` +
            ` ä¸Šé™: ${MAX_VARS_GLOBAL} ãƒã‚¹ï¼‰`;
        }
      }
    };
  })();
  </script>
</body>
</html>
