<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #f0f0f0;
      padding: 10px;
      user-select: none;
    }
    h1 {
      font-size: 24px;
      margin: 10px 0;
    }
    h2 {
      font-size: 14px;
      margin: 5px 0 15px;
      text-align: center;
      line-height: 1.6;
    }
    #controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    button {
      padding: 12px 24px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #2196f3;
      color: white;
    }
    button:disabled {
      opacity: 0.6;
      cursor: default;
    }
    #status {
      font-size: 18px;
      font-weight: bold;
      margin-top: 10px;
    }
    #board {
      display: grid;
      gap: 2px;
      box-sizing: border-box;
      margin: 0 auto;
      transition: all 0.2s ease-in-out;
    }
    .cell {
      background: #bbb;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      color: #333;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s;
      aspect-ratio: 1 / 1;
      user-select: none;
    }
    .cell.open {
      background: #e0e0e0;
    }
    .cell.flag {
      background: #ffeb3b;
      color: #d32f2f;
    }
    .cell.mine {
      background: #f44336;
      color: white;
    }
    .timer {
      font-size: 20px;
      font-weight: bold;
      margin-top: 10px;
    }

    /* å®‰å…¨ãƒã‚¹ï¼šå¤ªãã¦æ˜ã‚‹ã„æ ï¼‹èƒŒæ™¯ã‚‚å°‘ã—å¤‰ãˆã‚‹ */
    .cell.hint-safe {
      outline: 4px solid #00e676;
      outline-offset: -1px;
      background: #c8f7dc;
    }

    /* åœ°é›·ç¢ºå®šãƒã‚¹ï¼šèµ¤æ  */
    .cell.hint-mine {
      outline: 3px solid #d50000;
      outline-offset: -1px;
    }

    /* ä¸€ç•ªå®‰å…¨å€™è£œãƒã‚¹ï¼šé’ç‚¹ç·šæ ï¼ˆè‡ªå‹•ã§ã¯é–‹ã‘ãªã„ï¼‰ */
    .cell.hint-best {
      outline: 3px dashed #2962ff;
      outline-offset: -1px;
    }

    @media (max-width: 600px) {
      button {
        font-size: 16px;
        padding: 10px 20px;
      }
      h1 {
        font-size: 20px;
      }
      #status, .timer {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <h1>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘</h1>
  <h2>
    1ãƒã‚¹ã§çˆ†å¼¾2å€‹åˆ†ã‚«ã‚¦ãƒ³ãƒˆã®é‡çˆ†å¼¾ãŒç´›ã‚Œè¾¼ã‚“ã§ã„ã‚‹ã€‚<br>
    ã¾ãŸã€æœ¬æ¥ã‚ˆã‚Š1å°‘ãªãè¡¨ç¤ºã•ã‚Œã‚‹å ´åˆãŒã‚ã‚‹ã€‚ï¼ˆæœ€å°å€¤1ï¼‰
  </h2>
  <div id="controls">
    <button id="resetButton">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
    <button id="goodStartButton">ğŸ¯ è‰¯ã„ç›¤é¢æ¢ã™</button>
  </div>
  <div id="status"></div>
  <div id="board"></div>
  <div id="timer" class="timer">æ™‚é–“: 0</div>

  <script>
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const resetButton = document.getElementById('resetButton');
    const timerEl = document.getElementById('timer');
    const goodStartButton = document.getElementById('goodStartButton');

    const size = 20;
    const mineCount = 100;
    const DECEPTION_PROBABILITY = 0.5; // æ•°å­—ãŒ1å°‘ãªããªã‚‹ç¢ºç‡
    const GOOD_RATIO = 0.25;          // ã€Œè‰¯ã„æ„Ÿã˜ã€ã®é–¾å€¤ï¼ˆ1/4ï¼‰
    const GOOD_BIG_NUMBER_MIN = 5;    // 4ä»¥ä¸Šã®æ•°å­—ã®æœ€ä½å€‹æ•°
    const GOOD_SEARCH_MAX_TRIES = 200; // ç›¤é¢ã®æœ€å¤§è©¦è¡Œå›æ•°
    const GOOD_SEARCH_MAX_RANDOM_CLICKS_PER_BOARD = 400; // 1ç›¤é¢ã‚ãŸã‚Šãƒ©ãƒ³ãƒ€ãƒ ã‚¯ãƒªãƒƒã‚¯ä¸Šé™

    let gameOver = false;
    let openedCount = 0;
    let board = [];
    let timer = null;
    let timerSeconds = 0;
    let firstClick = null; // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ä½ç½®ï¼ˆãã®å‘¨å›²ã¯å®‰å…¨ï¼‰

    // è‰¯ã„ç›¤é¢æ¢ç´¢ç”¨
    let goodSearchRunning = false;
    let goodSearchTries = 0;
    let goodSearchTimeout = null;
    let goodSearchRandomClicksOnBoard = 0;

    resetButton.addEventListener('click', () => {
      stopGoodSearch();
      init();
    });
    goodStartButton.addEventListener('click', startGoodSearch);

    function init() {
      board = [];
      gameOver = false;
      openedCount = 0;
      firstClick = null;
      statusEl.textContent = '';
      boardEl.innerHTML = '';
      timerSeconds = 0;
      timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
      clearInterval(timer);
      timer = setInterval(() => {
        if (!gameOver) {
          timerSeconds++;
          timerEl.textContent = `æ™‚é–“: ${timerSeconds}`;
        }
      }, 1000);

      const shortSide = Math.min(window.innerWidth, window.innerHeight) * 0.9;
      boardEl.style.width = `${shortSide}px`;
      boardEl.style.height = `${shortSide}px`;
      boardEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      boardEl.style.gridTemplateRows = `repeat(${size}, 1fr)`;

      for (let y = 0; y < size; y++) {
        board[y] = [];
        for (let x = 0; x < size; x++) {
          const cellEl = document.createElement('div');
          cellEl.className = 'cell';
          boardEl.appendChild(cellEl);

          const cell = {
            x, y,
            mine: null,           // null / "normal" / "heavy"ï¼ˆå†…éƒ¨ï¼‰
            open: false,
            flag: false,          // è‡ªå‹•ãƒ•ãƒ©ã‚°
            flagType: null,       // null / "unknown" / "normal" / "heavy"
            count: 0,             // çœŸã®ã‚«ã‚¦ãƒ³ãƒˆï¼ˆå†…éƒ¨ï¼‰
            displayCount: null,   // ç”»é¢ä¸Šã®æ•°å­—ï¼ˆæ¨è«–ã¯ã“ã‚Œã ã‘ä½¿ç”¨ï¼‰
            hintStatus: null,     // null / "safe" / "mine"
            el: cellEl
          };
          board[y][x] = cell;

          cellEl.addEventListener('click', () => handleCellClick(cell));
        }
      }

      clearHintsAndFlags();
      updateHints(); // ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚ã¯æƒ…å ±ã‚¼ãƒ­ãªã®ã§ä½•ã‚‚å‡ºãªã„
    }

    function handleCellClick(cell) {
      if (gameOver || cell.open) return;
      if (cell.flag) return; // æ——ãŒã‚ã‚‹ã¨ã“ã‚ã¯æŠ¼ã•ãªã„

      if (!firstClick) {
        firstClick = { x: cell.x, y: cell.y };
        placeMines();
      }

      openCell(cell);

      if (cell.mine) {
        cell.el.classList.add('mine');
        cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
        endGame(false);
        return;
      }

      if (cell.count === 0) {
        openSurrounding(cell.x, cell.y);
      }

      updateHints();

      if (openedCount === size * size - mineCount) {
        endGame(true);
      }
    }

    function placeMines() {
      let mines = 0;
      const safeCells = new Set();

      // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã¨ãã®å‘¨å›²3x3ã¯åœ°é›·ç¦æ­¢
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = firstClick.x + dx;
          const ny = firstClick.y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            safeCells.add(`${nx},${ny}`);
          }
        }
      }

      // é‡çˆ†å¼¾ã®å€‹æ•°ï¼ˆã‚»ãƒ«ã®æ•°ï¼‰ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ±ºã‚ã‚‹
      const heavyMineCount = Math.floor(Math.random() * (mineCount + 1));
      let heavyMines = 0;

      while (mines < mineCount) {
        const x = Math.floor(Math.random() * size);
        const y = Math.floor(Math.random() * size);
        const cell = board[y][x];

        if (!cell.mine && !safeCells.has(`${x},${y}`)) {
          if (heavyMines < heavyMineCount) {
            cell.mine = "heavy";
            heavyMines++;
          } else {
            cell.mine = "normal";
          }
          mines++;
        }
      }

      // çœŸã®ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨ˆç®—ï¼ˆå†…éƒ¨å°‚ç”¨ï¼‰
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.mine) continue;
          cell.count = getMineCount(x, y);
        }
      }
    }

    function getMineCount(x, y) {
      let count = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
          if (dx === 0 && dy === 0) continue;
          const neighbor = board[ny][nx];
          if (neighbor.mine === "normal") count += 1;
          else if (neighbor.mine === "heavy") count += 2;
        }
      }
      return count;
    }

    function openCell(cell) {
      if (cell.open || gameOver) return;
      cell.open = true;
      openedCount++;
      cell.el.classList.add('open');

      // å¿µã®ãŸã‚ã€é–‹ã„ãŸã‚»ãƒ«ã®æ——ã¯æ¶ˆã™
      if (cell.flag) {
        cell.flag = false;
        cell.flagType = null;
        cell.el.classList.remove('flag');
      }

      if (!cell.mine) {
        if (cell.count === 0) {
          cell.displayCount = 0;
          cell.el.textContent = '';
        } else {
          let displayCount = cell.count;
          if (Math.random() < DECEPTION_PROBABILITY) {
            displayCount = Math.max(1, cell.count - 1);
          }
          cell.displayCount = displayCount; // æ¨è«–ã¯ã“ã‚Œã ã‘ã‚’è¦‹ã‚‹
          cell.el.textContent = displayCount;
          cell.el.style.color = getNumberColor(displayCount);
        }
      }
    }

    function getNumberColor(num) {
      switch (num) {
        case 1: return '#1976d2';
        case 2: return '#388e3c';
        case 3: return '#d32f2f';
        case 4: return '#7b1fa2';
        case 5: return '#f57c00';
        case 6: return '#00897b';
        case 7: return '#616161';
        case 8: return '#000000';
        default: return '#000000';
      }
    }

    function openSurrounding(x, y) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= size || ny >= size) continue;
          if (dx === 0 && dy === 0) continue;
          const neighbor = board[ny][nx];
          if (!neighbor.open && !neighbor.mine) {
            openCell(neighbor);
            if (neighbor.count === 0) {
              openSurrounding(nx, ny);
            }
          }
        }
      }
    }

    function endGame(win) {
      gameOver = true;
      clearInterval(timer);
      statusEl.textContent = win ? 'ã‚¯ãƒªã‚¢ï¼' : 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼';

      // ã‚²ãƒ¼ãƒ çµ‚äº†å¾Œã ã‘å†…éƒ¨æƒ…å ±ã‚’å…¨é–‹ç¤º
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.mine && !cell.open) {
            cell.el.classList.add('mine');
            cell.el.textContent = cell.mine === "heavy" ? 'ğŸ’¥' : 'ğŸ’£';
          }
        }
      }
      // è‰¯ã„ç›¤é¢æ¢ç´¢ä¸­ã§ã‚‚ã“ã“ã§ã¯æ­¢ã‚ãªã„ï¼ˆæ¢ç´¢å´ã§ gameOver ã‚’è¦‹ã¦å‡¦ç†ï¼‰
    }

    // ======== è‰¯ã„ç›¤é¢æ¢ç´¢ãƒ­ã‚¸ãƒƒã‚¯ ========

    function startGoodSearch() {
      if (goodSearchRunning) return;
      goodSearchRunning = true;
      goodSearchTries = 0;
      goodSearchRandomClicksOnBoard = 0;
      goodStartButton.disabled = true;
      statusEl.textContent = 'è‰¯ã„æ„Ÿã˜ã®ç›¤é¢ã‚’æ¢ç´¢ä¸­...';
      startNewBoardForGoodSearch();
    }

    function stopGoodSearch() {
      goodSearchRunning = false;
      if (goodSearchTimeout) {
        clearTimeout(goodSearchTimeout);
        goodSearchTimeout = null;
      }
      goodStartButton.disabled = false;
    }

    function startNewBoardForGoodSearch() {
      if (!goodSearchRunning) return;

      if (goodSearchTries >= GOOD_SEARCH_MAX_TRIES) {
        statusEl.textContent =
          `è‰¯ã„æ„Ÿã˜ã®ç›¤é¢ãŒ ${GOOD_SEARCH_MAX_TRIES} å›ä»¥å†…ã«ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ`;
        stopGoodSearch();
        return;
      }
      goodSearchTries++;
      goodSearchRandomClicksOnBoard = 0;

      // æ–°ã—ã„ç›¤é¢ã‚’ä½œæˆ
      init();

      // çœŸã‚“ä¸­ã‚’è‡ªå‹•ã‚¯ãƒªãƒƒã‚¯
      const cx = Math.floor(size / 2);
      const cy = Math.floor(size / 2);
      const centerCell = board[cy][cx];
      handleCellClick(centerCell); // ã“ã“ã§ãƒ­ã‚¸ãƒƒã‚¯ãŒåºƒãŒã‚Šã€updateHints() ã‚‚èµ°ã‚‹

      if (gameOver) {
        // ã„ããªã‚Šçˆ†æ­»ã—ãŸã‚‰æ¬¡ã®ç›¤é¢ã¸
        goodSearchTimeout = setTimeout(startNewBoardForGoodSearch, 50);
        return;
      }

      if (isGoodBoard()) {
        statusEl.textContent =
          `è‰¯ã„æ„Ÿã˜ã®ç›¤é¢ã‚’è¦‹ã¤ã‘ã¾ã—ãŸï¼ï¼ˆè©¦è¡Œå›æ•°: ${goodSearchTries}å›ï¼‰`;
        stopGoodSearch();
        return;
      }

      // ãƒ©ãƒ³ãƒ€ãƒ ã‚¯ãƒªãƒƒã‚¯ãƒ«ãƒ¼ãƒ—ã¸
      goodSearchTimeout = setTimeout(runRandomClickOnCurrentBoard, 50);
    }

    function runRandomClickOnCurrentBoard() {
      if (!goodSearchRunning) return;

      if (isGoodBoard()) {
        statusEl.textContent =
          `è‰¯ã„æ„Ÿã˜ã®ç›¤é¢ã‚’è¦‹ã¤ã‘ã¾ã—ãŸï¼ï¼ˆè©¦è¡Œå›æ•°: ${goodSearchTries}å›, ãƒ©ãƒ³ãƒ€ãƒ ã‚¯ãƒªãƒƒã‚¯: ${goodSearchRandomClicksOnBoard}å›ï¼‰`;
        stopGoodSearch();
        return;
      }

      if (gameOver) {
        // ã“ã®ç›¤é¢ã¯çµ‚äº†ã—ãŸã®ã§ã€æ¬¡ã®ç›¤é¢ã¸
        goodSearchTimeout = setTimeout(startNewBoardForGoodSearch, 50);
        return;
      }

      if (goodSearchRandomClicksOnBoard >= GOOD_SEARCH_MAX_RANDOM_CLICKS_PER_BOARD) {
        // ã“ã®ç›¤é¢ã§ã®æ¢ç´¢ã¯è«¦ã‚ã¦æ¬¡ã¸
        goodSearchTimeout = setTimeout(startNewBoardForGoodSearch, 50);
        return;
      }

      // ãƒ©ãƒ³ãƒ€ãƒ ã«ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹å€™è£œã‚’é›†ã‚ã‚‹
      const candidates = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.open) continue;
          if (cell.flag) continue;
          if (cell.hintStatus === 'mine') continue; // åœ°é›·ç¢ºå®šã¯é¿ã‘ã‚‹
          candidates.push(cell);
        }
      }

      if (candidates.length === 0) {
        // ã‚‚ã†æŠ¼ã›ã‚‹ã¨ã“ã‚ãŒãªã„ â†’ æ¬¡ã®ç›¤é¢ã¸
        goodSearchTimeout = setTimeout(startNewBoardForGoodSearch, 50);
        return;
      }

      // å®Œå…¨ãƒ©ãƒ³ãƒ€ãƒ ã§1ãƒã‚¹é¸ã‚“ã§ã‚¯ãƒªãƒƒã‚¯
      const idx = Math.floor(Math.random() * candidates.length);
      const target = candidates[idx];
      goodSearchRandomClicksOnBoard++;
      handleCellClick(target);

      // æ¬¡ã®ãƒ©ãƒ³ãƒ€ãƒ ã‚¯ãƒªãƒƒã‚¯ã¸
      goodSearchTimeout = setTimeout(runRandomClickOnCurrentBoard, 50);
    }

    function isGoodBoard() {
      const totalCells = size * size;
      let solvedOrFlagged = 0;
      let bigNumberCount = 0; // è¡¨ç¤º4ä»¥ä¸Šã®æ•°å­—ãƒã‚¹ã®å€‹æ•°
      let openedCells = 0;
      let openedNumberGe2 = 0; // é–‹ã„ãŸãƒã‚¹ã®ã†ã¡è¡¨ç¤º2ä»¥ä¸Šã®å€‹æ•°

      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];

          if (cell.open) {
            openedCells++;
            solvedOrFlagged++;
            // 4ä»¥ä¸Šã®æ•°å­—
            if (cell.displayCount != null && cell.displayCount >= 4) {
              bigNumberCount++;
            }
            // 2ä»¥ä¸Šã®æ•°å­—
            if (cell.displayCount != null && cell.displayCount >= 2) {
              openedNumberGe2++;
            }
          } else if (!cell.open && cell.flag && cell.hintStatus === 'mine') {
            // è«–ç†çš„ã«ç¢ºå®šã—ãŸåœ°é›·ãƒã‚¹
            solvedOrFlagged++;
          }
        }
      }

      // æ¡ä»¶1: æ—¢å­˜å®šç¾©
      const enoughSolved = solvedOrFlagged >= totalCells * GOOD_RATIO;
      const enoughBigNumbers = bigNumberCount >= GOOD_BIG_NUMBER_MIN;
      const condition1 = enoughSolved && enoughBigNumbers;

      // æ¡ä»¶2: ã€Œ50ãƒã‚¹ä»¥ä¸Šé–‹ã„ã¦ã„ã¦ã€ãã®ã†ã¡8å‰²ä»¥ä¸ŠãŒ2ä»¥ä¸Šã®æ•°å­—ã€
      let condition2 = false;
      if (openedCells >= 50) {
        condition2 = (openedNumberGe2 >= openedCells * 0.8);
      }

      return condition1 || condition2;
    }

    // ======== è£œåŠ©é–¢æ•°ï¼ˆãƒ’ãƒ³ãƒˆãƒ»ç¯„å›²æ¨è«–ï¼‰ ========

    function clearHintsAndFlags() {
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const c = board[y][x];
          c.hintStatus = null;
          c.el.classList.remove('hint-safe', 'hint-mine', 'hint-best');

          // ãƒ•ãƒ©ã‚°ã¯æ¨è«–ã”ã¨ã«ä»˜ã‘ç›´ã™ã®ã§ä¸€æ—¦ãƒªã‚»ãƒƒãƒˆ
          if (!c.open) {
            c.flag = false;
            c.flagType = null;
            c.el.classList.remove('flag');
            c.el.textContent = '';
          }
        }
      }
    }

    function getNeighbors(x, y) {
      const res = [];
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            res.push(board[ny][nx]);
          }
        }
      }
      return res;
    }

    function markSafe(cell) {
      if (cell.hintStatus === "mine") return;
      cell.hintStatus = "safe";
      cell.el.classList.add('hint-safe');
    }

    function markMine(cell, mineType) {
      cell.hintStatus = "mine";
      cell.el.classList.add('hint-mine');

      // ç¢ºå®šåœ°é›·ã«ã¯è‡ªå‹•ãƒ•ãƒ©ã‚°ï¼ˆ1 / 2 / ?ï¼‰
      cell.flag = true;
      cell.flagType = mineType;
      cell.el.classList.add('flag');

      if (mineType === "normal") {
        cell.el.textContent = '1';
      } else if (mineType === "heavy") {
        cell.el.textContent = '2';
      } else {
        cell.el.textContent = 'ğŸš©?';
      }
    }

    function markBestCells(cells) {
      for (const cell of cells) {
        cell.el.classList.add('hint-best');
      }
    }

    // ======== ãƒ¡ã‚¤ãƒ³æ¨è«–ï¼ˆç¯„å›²[min,max] ä¼æ’­ï¼‰ ========

    function updateHints() {
      clearHintsAndFlags();
      if (gameOver) return;
      if (!firstClick) return; // ã¾ã ä½•ã‚‚é–‹ã„ã¦ã„ãªã„

      // ---- 1. å…¨ãƒã‚¹ã®åˆæœŸ low/high ----
      const low = [];
      const high = [];

      for (let y = 0; y < size; y++) {
        low[y] = [];
        high[y] = [];
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.open) {
            // é–‹ã„ã¦ã„ã‚‹ãƒã‚¹ã¯å¿…ãšåœ°é›·0
            low[y][x] = 0;
            high[y][x] = 0;
          } else {
            // é–‰ã˜ã¦ã„ã‚‹ãƒã‚¹ã¯ 0ã€œ2 ã®ã©ã‚Œã§ã‚‚ã‚ã‚Šã†ã‚‹
            low[y][x] = 0;
            high[y][x] = 2;
          }
        }
      }

      // ---- 2. æ•°å­—ãƒã‚¹ã‹ã‚‰åˆ¶ç´„ã‚’ä½œã‚‹ ----
      const constraints = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (!cell.open) continue;
          if (cell.displayCount == null) continue;

          const d = cell.displayCount;
          const neighbors = getNeighbors(x, y);
          const vars = neighbors.filter(n => !n.open);
          if (vars.length === 0) continue;

          let L, U;
          if (d === 0) {
            L = 0; U = 0;
          } else {
            L = d;
            U = d + 1;
          }

          constraints.push({
            vars, baseL: L, baseU: U
          });
        }
      }

      // ---- 3. åˆ¶ç´„ã‚’ä½¿ã£ãŸ min/max ã®åå¾©ä¼æ’­ ----
      const MAX_ITER = 50;
      for (let iter = 0; iter < MAX_ITER; iter++) {
        let changed = false;

        for (const c of constraints) {
          const vars = c.vars;
          if (vars.length === 0) continue;

          // ã¾ãšä»Šã® low/high ã‹ã‚‰åˆè¨ˆã®æœ€å°ãƒ»æœ€å¤§ã‚’è¨ˆç®—
          let sumLow = 0;
          let sumHigh = 0;
          for (const v of vars) {
            const lv = low[v.y][v.x];
            const hv = high[v.y][v.x];
            sumLow += lv;
            sumHigh += hv;
          }

          // åˆ¶ç´„ã®å…ƒã€…ã®ç¯„å›² [baseL, baseU] ã¨ [sumLow,sumHigh] ã‚’äº¤å·®
          let L = Math.max(c.baseL, sumLow);
          let U = Math.min(c.baseU, sumHigh);
          if (L > U) {
            // çŸ›ç›¾ã¯èµ·ããªã„å‰æã ãŒä¿é™ºã§
            L = U;
          }

          // å„å¤‰æ•°ã”ã¨ã« x_k ã®ä¸‹é™ãƒ»ä¸Šé™ã‚’æ›´æ–°
          for (const v of vars) {
            const lv = low[v.y][v.x];
            const hv = high[v.y][v.x];

            const othersLow = sumLow - lv;
            const othersHigh = sumHigh - hv;

            // sum >= L ã‹ã‚‰ x_k >= L - Î£_{jâ‰ k} high_j
            let newLow = Math.max(lv, L - othersHigh, 0);
            // sum <= U ã‹ã‚‰ x_k <= U - Î£_{jâ‰ k} low_j
            let newHigh = Math.min(hv, U - othersLow, 2);

            if (newLow > newHigh) {
              // ã“ã“ã‚‚çŸ›ç›¾æ¤œå‡ºã ãŒã€ã‚²ãƒ¼ãƒ ã§ã¯èµ·ããªã„å‰æ
              continue;
            }

            if (newLow !== lv) {
              low[v.y][v.x] = newLow;
              changed = true;
            }
            if (newHigh !== hv) {
              high[v.y][v.x] = newHigh;
              changed = true;
            }
          }
        }

        if (!changed) break;
      }

      // ---- 4. low/high ã‹ã‚‰ç¢ºå®šå®‰å…¨ï¼ç¢ºå®šåœ°é›·ã‚’æ±ºå®š ----
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.open) continue;

          const lv = low[y][x];
          const hv = high[y][x];

          // high == 0 â†’ 0 ã—ã‹ã‚ã‚Šå¾—ãªã„ = å®‰å…¨ç¢ºå®š
          if (hv === 0) {
            markSafe(cell);
          }

          // low >= 1 â†’ 1ã‹2ã®ã©ã¡ã‚‰ã‹ = åœ°é›·ç¢ºå®š
          if (lv >= 1) {
            let type = "unknown";
            if (lv === 1 && hv === 1) type = "normal";
            else if (lv === 2 && hv === 2) type = "heavy";
            else type = "unknown"; // 1ã‹2ã‹åˆ†ã‹ã‚‰ãªã„
            markMine(cell, type);
          }
        }
      }

      // ---- 5. ç¢ºå®šå®‰å…¨ãƒã‚¹ã ã‘è‡ªå‹•ã§é–‹ã‘ã‚‹ ----
      const openedBefore = openedCount;
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (!cell.open && cell.hintStatus === "safe" && !cell.flag && !gameOver) {
            openCell(cell);
            if (cell.count === 0) {
              openSurrounding(cell.x, cell.y);
            }
          }
        }
      }

      if (!gameOver && openedCount > openedBefore) {
        // æ–°ã—ã„æƒ…å ±ãŒå¢—ãˆãŸã®ã§ã€ã‚‚ã†ä¸€å›è«–ç†æ¨è«–
        updateHints();
        return;
      }

      // ---- 6. ãã‚Œã§ã‚‚ç¢ºå®šå®‰å…¨ãŒãªã„å ´åˆã€ã€Œä¸€ç•ªå®‰å…¨ãã†ãªå€™è£œã€ã‚’è©•ä¾¡ï¼ˆè¡¨ç¤ºã ã‘ï¼‰ ----

      // ãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢ï¼ˆæ•°å­—ã«éš£æ¥ã—ã¦ã„ã‚‹æœªç¢ºå®šãƒã‚¹ï¼‰
      const frontier = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const cell = board[y][x];
          if (cell.open) continue;
          const ns = getNeighbors(x, y);
          let hasOpenNumber = false;
          for (const n of ns) {
            if (n.open && n.displayCount != null && n.displayCount > 0) {
              hasOpenNumber = true;
              break;
            }
          }
          if (hasOpenNumber) frontier.push(cell);
        }
      }

      // ã“ã®ã‚»ãƒ«ã®ã€Œdomain ãƒªã‚¹ã‚¯ã€ã‚’è¨ˆç®—ï¼ˆ0/1/2 ã®å€™è£œã‹ã‚‰ï¼‰
      function domainRiskFor(lv, hv) {
        const vals = [];
        if (lv <= 0 && 0 <= hv) vals.push(0);
        if (lv <= 1 && 1 <= hv) vals.push(1);
        if (lv <= 2 && 2 <= hv) vals.push(2);
        if (vals.length === 0) return 1; // ã‚ã‚Šãˆãªã„ãŒã€ä¿é™ºã§æœ€å¤§ãƒªã‚¹ã‚¯

        let mineCount = 0;
        for (const v of vals) {
          if (v >= 1) mineCount++;
        }
        return mineCount / vals.length; // ã€Œçˆ†ç™ºã™ã‚‹å€¤ã€ã®å‰²åˆ
      }

      // å‘¨å›²ã®æ•°å­—ã‹ã‚‰ã®ã€Œå±€æ‰€ãƒªã‚¹ã‚¯ã€ï¼ˆæ•°å­—å¯†åº¦ï¼‰
      function localNumberRisk(cell) {
        const ns = getNeighbors(cell.x, cell.y);
        let sum = 0, cnt = 0;
        for (const numCell of ns) {
          if (!numCell.open) continue;
          if (numCell.displayCount == null || numCell.displayCount === 0) continue;
          const d = numCell.displayCount;
          const around = getNeighbors(numCell.x, numCell.y);
          let unk = 0;
          for (const a of around) if (!a.open) unk++;
          if (unk === 0) continue;
          const r = Math.min(1, d / unk);
          sum += r;
          cnt++;
        }
        if (cnt === 0) return null;
        return sum / cnt;
      }

      let bestRisk = Infinity;
      let bestCells = [];

      for (const cell of frontier) {
        if (cell.open || cell.flag) continue;

        const lv = low[cell.y][cell.x];
        const hv = high[cell.y][cell.x];

        // å®‰å…¨ç¢ºå®š or åœ°é›·ç¢ºå®šã¯é™¤å¤–
        if (hv === 0) continue;
        if (lv >= 1) continue;

        const dRisk = domainRiskFor(lv, hv);
        let nRisk = localNumberRisk(cell);
        if (nRisk == null) nRisk = dRisk;

        const combined = 0.4 * dRisk + 0.6 * nRisk;

        if (combined < bestRisk - 1e-9) {
          bestRisk = combined;
          bestCells = [cell];
        } else if (Math.abs(combined - bestRisk) < 1e-9) {
          bestCells.push(cell);
        }
      }

      if (bestCells.length > 0 && bestRisk < Infinity) {
        // ã€Œä¸€ç•ªãƒã‚·ãªå€™è£œã€ã‚’é’æ ã§è¡¨ç¤ºã™ã‚‹ã ã‘ï¼ˆè‡ªå‹•ã‚¯ãƒªãƒƒã‚¯ã¯ã—ãªã„ï¼‰
        markBestCells(bestCells);
      }
    }

    init();
  </script>
</body>
</html>
